<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>孤独的WebGL之旅(一) | Hello, WebGL.</title>
      <link href="/2020/01/20/webgl(1)/"/>
      <url>/2020/01/20/webgl(1)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在这悲哀的山巅，请用你的眼泪诅咒我、祝福我，不要温和地走入那个良夜。</p></blockquote><p>作为与<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night" target="_blank" rel="noopener">项目</a>一致的记录而存在。</p><p>是对曾经没有时间完善的WebGL项目的追溯，也是一个重新学习原生WebGL的过程。</p><p>  </p><h3 id="创建与设置画布"><a class="markdownIt-Anchor" href="#创建与设置画布"></a> 创建与设置画布</h3><hr><p>我们用H5新引入的<code>&lt;canvas&gt;</code>标签作为绘图区域，它允许JavaScript动态绘制图形。由于canvas是透明的，在canvas间加入的信息只会在不支持WebGL的浏览器上显示，这可以作为错误提示。</p><p>对canvas内容的操作与绘制将通过JavaScript代码来实现，我们可以用<code>&lt;script&gt;&lt;/script&gt;</code>标签引入对应的JS代码。</p><p>用body标签指定JS程序的入口。</p><pre class="highlight"><code class="html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebGL<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./lib/jquery-3.3.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./css/style.css"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;script type="text/javascript" src="./js/windowResize.js"&gt;&lt;/script&gt; --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">"main()"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"canvas"</span>&gt;</span>      Please use a browser that supports "canvas"    <span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./js/draw.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p> </p><p>我们预想的canvas应该自适应撑满整个屏幕，曾经在写类似前端需求时碰到过一个问题，就是会有高度上的滚动条出现，为了解决这个问题，抄了一些网上的css，使canvas的宽度和高度都可以适应全屏幕。对了，为了代码的可阅读性，html文件在根目录，其他所有的css,js,之后的着色器、model等都将独立设置子目录。</p><p>css代码如下：</p><pre class="highlight"><code class="css"><span class="hljs-comment">/* style.css */</span><span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">canvas</span> {  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">font-family</span>: Monospace;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;  <span class="hljs-attribute">overflow</span>: hidden;}* {  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;}<span class="hljs-selector-tag">canvas</span> {  <span class="hljs-attribute">display</span>: block;}</code></pre><p> </p><p>加入这段代码后，你会发现body所在的区域全都变成黑色了，并且没有滚动条出现。但当用F12开发者工具观察时，你会发现canvas所在区域的高度并没有占满整个屏幕。这时候我们需要用到JQuery来动态设置canvas的高度。注意，使用JQuery要引入JQuery文件，我把它放在了/lib文件夹里。</p><p>你可以选择监听窗口的大小变化然后实时刷新canvas的size，注意每次刷新后都会丢失canvas的内容，需要重新绘制。注释掉的windowResize.js即为动态刷新的代码，如下所示：</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">//windowResize.js</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{  $(<span class="hljs-built_in">window</span>).resize(resizeCanvas);  resizeCanvas();});<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resizeCanvas</span>(<span class="hljs-params"></span>)</span>{  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"width"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerWidth);  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"height"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerHeight);};</code></pre><p> </p><p>不过我暂时没有想好把canvas和window一起重绘的代码放在哪里，所以这里我采用了只在window初始化的时候确定canvas的size，所以这段代码被放在了main的初始化阶段。和绘制的代码放在一起，便于我观察测试：</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">//draw.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{  <span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);  <span class="hljs-keyword">if</span>(!canvas){    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failed to get the &lt;canvas&gt; element'</span>);    <span class="hljs-keyword">return</span> ;  }  <span class="hljs-comment">//自适应一开始的页面大小</span>  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"width"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerWidth);  $(<span class="hljs-string">"canvas"</span>).attr(<span class="hljs-string">"height"</span>, $(<span class="hljs-built_in">window</span>).get(<span class="hljs-number">0</span>).innerHeight);  <span class="hljs-keyword">var</span> context = canvas.getContext(<span class="hljs-string">'2d'</span>);  context.fillStyle = <span class="hljs-string">'rgba(0, 0, 255, 1.0)'</span>;  context.fillRect(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>);}</code></pre><p> </p><h3 id="尝试绘制"><a class="markdownIt-Anchor" href="#尝试绘制"></a> 尝试绘制</h3><hr><p>绘制主要通过js进行，代码已经在上面的draw.js里了。我们首先通过id获取canvas对象，但绘制并不是直接通过canvas对象进行的，而是由canvas提供的上下文对象(context)来进行的。getContext参数指定了绘制对象的类型是2d还是3d，这里我们测试画的是一个矩形，所以是2d对象。</p><p>fillStyle可以理解为画笔颜色，这里用的是Alpha=1.0的蓝色。RGB的范围都是0-255，alpha的范围是0-1.0。</p><p>关于WebGL的坐标系统，原点在屏幕左上角，x轴从左到右，y轴从上到下。fillRect方法前两个参数是矩形的左上角坐标，后两个参数对应矩形的x轴方向长度和y轴方向长度(即宽度和高度)。</p><p>绘制效果如下图所示：</p><p><img src="/article/webgl(1)/1.png" alt="aa"></p><p>这只是一个尝试在canvas上绘制图形的过程，真正的WebGL编程远比这个繁琐。</p><h3 id="着色器相关"><a class="markdownIt-Anchor" href="#着色器相关"></a> 着色器相关</h3><hr><h4 id="函数库"><a class="markdownIt-Anchor" href="#函数库"></a> 函数库</h4><p>注意，从这里开始我们将引入参考资料里的一些程序，这些程序大都是一些事先定义好的函数库，方便我们获取一些对象，隐去不同浏览器之间的差异，但是我们的主要编程部分仍然是遵循原生WebGL的主旨。</p><p>同时，为了避免以后不同函数库之间命名冲突的问题(曾经给我的CG大程造成了很大的麻烦)，我将建立自己的函数库，大致考虑分为两个，一个是WebGL-utils.js，注重于WebGL方面的初始化过程，另一个是math-utils.js，注重矩阵计算方面。有一个叫WebGL-debug.js的东西是用来显示debug信息的，这个是从参考资料代码里照搬的。</p><p> </p><h4 id="着色器"><a class="markdownIt-Anchor" href="#着色器"></a> 着色器</h4><p>着色器是WebGL最重要的概念之一，绘图过程必须用到着色器。WebGL需要两种着色器——顶点着色器(Vertex Shader)和片元着色器(Fragment Shader)，用GLSL语言编写。</p><p>顶点着色器是用来描述顶点特性(如位置、颜色等)的程序。片元着色器进行逐片元处理过程(如光照)。绘图的过程是，浏览器执行JS程序——JS执行WebGL相关方法——顶点着色器逐顶点操作，片元着色器逐片元操作——渲染到颜色缓冲区——显示在浏览器上。</p><p><img src="/article/webgl(1)/2.png" alt></p><p>不过虽然着色器代码是用GLSL语言编写的，创建着色器对象的过程中，程序接收的必须是字符串类型的对象，下面将介绍三种在JS代码中插入GLSL代码并创建着色器的方式。</p><p> </p><h4 id="用字符串存储着色器"><a class="markdownIt-Anchor" href="#用字符串存储着色器"></a> 用字符串存储着色器</h4><p>在参考资料书中，用到的都是这一种。直接在js代码内用字符串变量存储GLSL代码。</p><pre class="highlight"><code class="javascript"><span class="hljs-comment">// Vertex shader program</span><span class="hljs-keyword">var</span> VSHADER_SOURCE =   <span class="hljs-string">'void main() {\n'</span> +  <span class="hljs-string">'  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n'</span> + <span class="hljs-comment">// Set the vertex coordinates of the point</span>  <span class="hljs-string">'  gl_PointSize = 10.0;\n'</span> +                    <span class="hljs-comment">// Set the point size</span>  <span class="hljs-string">'}\n'</span>;<span class="hljs-comment">// Fragment shader program</span><span class="hljs-keyword">var</span> FSHADER_SOURCE =  <span class="hljs-string">'void main() {\n'</span> +  <span class="hljs-string">'  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n'</span> + <span class="hljs-comment">// Set the point color</span>  <span class="hljs-string">'}\n'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{  ...  <span class="hljs-comment">// Initialize shaders</span>  <span class="hljs-keyword">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failed to intialize shaders.'</span>);    <span class="hljs-keyword">return</span>;  }  ...}</code></pre><p>initShader()函数是函数库WebGL-utils.js中的一个函数，如果你对WebGL如何创建着色器的过程不感兴趣，你可以直接调用这个函数，忽略内部细节。注意第二第三个参数必须为字符串。</p><p>使用’\n’而不是直接用长字符串的原因是，这样做，当着色器内部出错时，就能获取出错的行号，对检查源代码错误很有帮助。</p><p>这种方法只适用于简单程序，书写很麻烦，创建和维护难度大。</p><p> </p><h4 id="内嵌于html代码中"><a class="markdownIt-Anchor" href="#内嵌于html代码中"></a> 内嵌于html代码中</h4><p>这种方法在网上的各种教程中很常见，通过设置<code>&lt;script&gt;</code>标签的type使得浏览器将内容视为数据块，不作为JS代码执行。</p><pre class="highlight"><code class="html">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"vertex-shader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"x-shader/x-vertex"</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">void</span> main(){        gl_Position = vec4(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">//设置坐标</span>        gl_PointSize = <span class="hljs-number">10.0</span>;  <span class="hljs-comment">//设置尺寸</span>      }    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fragment-shader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"x-shader/x-fragment"</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">void</span> main(){        gl_FragColor = vec4(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);  <span class="hljs-comment">//设置颜色</span>      }    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>在JS代码中还要将标签内容转为字符串，具体代码可以参考以下(这里的代码其实包含了创建着色器的内部细节，如果不想关心，可以将initShaders函数放到函数库里，传给函数的第二三个参数是着色器代码所在script标签的id)：</p><pre class="highlight"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{    ...    program = initShaders(gl, <span class="hljs-string">"vertex-shader"</span>, <span class="hljs-string">"fragment-shader"</span>);    gl.useProgram(program); <span class="hljs-comment">// 启用该shader程序对象 </span>    ...}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initShaders</span>(<span class="hljs-params"> gl, vertexShaderId, fragmentShaderId </span>)</span>{    <span class="hljs-keyword">var</span> vertShdr;    <span class="hljs-keyword">var</span> fragShdr;    <span class="hljs-keyword">var</span> vertElem = <span class="hljs-built_in">document</span>.getElementById( vertexShaderId );    <span class="hljs-keyword">if</span> ( !vertElem ) {         alert( <span class="hljs-string">"Unable to load vertex shader "</span> + vertexShaderId );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">else</span> {        vertShdr = gl.createShader( gl.VERTEX_SHADER );        gl.shaderSource( vertShdr, vertElem.text );        gl.compileShader( vertShdr );        <span class="hljs-keyword">if</span> ( !gl.getShaderParameter(vertShdr, gl.COMPILE_STATUS) ) {            <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Vertex shader failed to compile.  The error log is:"</span>          + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getShaderInfoLog( vertShdr ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;            alert( msg );            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }    }    <span class="hljs-keyword">var</span> fragElem = <span class="hljs-built_in">document</span>.getElementById( fragmentShaderId );    <span class="hljs-keyword">if</span> ( !fragElem ) {         alert( <span class="hljs-string">"Unable to load vertex shader "</span> + fragmentShaderId );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">else</span> {        fragShdr = gl.createShader( gl.FRAGMENT_SHADER );        gl.shaderSource( fragShdr, fragElem.text );        gl.compileShader( fragShdr );        <span class="hljs-keyword">if</span> ( !gl.getShaderParameter(fragShdr, gl.COMPILE_STATUS) ) {            <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Fragment shader failed to compile.  The error log is:"</span>          + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getShaderInfoLog( fragShdr ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;            alert( msg );            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        }    }    <span class="hljs-keyword">var</span> program = gl.createProgram();    gl.attachShader( program, vertShdr );    gl.attachShader( program, fragShdr );    gl.linkProgram( program );        <span class="hljs-keyword">if</span> ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) {        <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"Shader program failed to link.  The error log is:"</span>            + <span class="hljs-string">"&lt;pre&gt;"</span> + gl.getProgramInfoLog( program ) + <span class="hljs-string">"&lt;/pre&gt;"</span>;        alert( msg );        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    }    <span class="hljs-keyword">return</span> program;}</code></pre><p>但我觉得把GLSL代码放在html里还是不好管理，html代码的可读性变差了，还是放在文件里容易维护，于是就有了第三个方法。</p><p> </p><h4 id="从文件加载着色器"><a class="markdownIt-Anchor" href="#从文件加载着色器"></a> 从文件加载着色器</h4><p>从文件加载着色器需要创建一个XMLHttpRequest对象request来加载指定文件，事实上后面我们加载model时也要用到类似方法。可以将加载着色器的过程视作一个资源加载的过程，甚至我是在获取canvas对象之前加载的，因为加载过程和绘图无关。</p><p>fileName指定了文件加载的路径，记得采用相对路径。onLoadShaderFile是注册的事件响应函数，它将在文件加载完成时被调用。加载的着色器代码被作为字符串对象存储，当两者都加载完成时，回到main()函数进行下一步操作。</p><p>关键代码如下：</p><pre class="highlight"><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadShaderFile</span>(<span class="hljs-params">fileName, shader</span>)</span>{  <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();  request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">if</span>(request.readyState === <span class="hljs-number">4</span> &amp;&amp; request.status !== <span class="hljs-number">404</span>){      onLoadShaderFile(request.responseText, shader);    }  }  request.open(<span class="hljs-string">'GET'</span>, fileName, <span class="hljs-literal">true</span>);  request.send();}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoadShaderFile</span>(<span class="hljs-params">fileString, type</span>)</span>{  <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'VERTEX_SHADER'</span>){    VERTEX_SHADER = fileString;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"vertex shader:"</span> + VERTEX_SHADER);  }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-string">'FRAGMENT_SHADER'</span>){    FRAGMENT_SHADER = fileString;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"vertex shader:"</span> + FRAGMENT_SHADER);  }   <span class="hljs-keyword">if</span>(VERTEX_SHADER &amp;&amp; FRAGMENT_SHADER){    FLAG_SHADER_LOADED = <span class="hljs-literal">true</span>;    main();  }}</code></pre><p>从文件加载意味着我们可以比较方便地管理多个着色器对象，这对WebGL高级编程或许有意义(我还没学到hhh)。</p><p> <br>至此,我们了解了三种加载着色器的方式，但对着色器内部代码的意义，以及如何使用着色器进行绘制还没有涉及。下面将通过一个简单的程序来说明。</p><p> </p><h3 id="简单的webgl程序"><a class="markdownIt-Anchor" href="#简单的webgl程序"></a> 简单的WebGL程序</h3><hr><p>下面我们将绘制一个最简单的图形——一个位于原点的10个像素大的红色的点。实际效果中将为一个矩形，因为对WebGL来说绘制矩形比绘制圆更快。</p><p> </p><h4 id="顶点着色器"><a class="markdownIt-Anchor" href="#顶点着色器"></a> 顶点着色器</h4><p>顶点着色器定义了点的相关性质，在这里我们定义了点的位置和大小：</p><pre class="highlight"><code class="glsl"><span class="hljs-type">void</span> main(){  <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">//设置坐标</span>  <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-number">10.0</span>;  <span class="hljs-comment">//设置尺寸</span>}</code></pre><p>gl_Position和gl_PointSize是顶点着色器内置的变量，你必须传值给这两个变量。不同于JS，GLSL是一种强类型的语言，gl_Position的类型是vec4，相当于长度为4的矢量，每个值的类型都是float。它表示顶点的齐次坐标。gl_PointSize的类型也是float，所以这里的10.0不能写成10。vec4是GLSL内置的构造函数，在JS里，通过math-utils.js的函数库，我们也创建了类似的一连串的vec2,vec3,vec4的构造函数。</p><p> </p><h4 id="webgl坐标系"><a class="markdownIt-Anchor" href="#webgl坐标系"></a> WebGL坐标系</h4><p>与canvas坐标系不同，WebGL坐标系的原点在canvas正中间，且是一个三维坐标系，具有x轴(从左往右)，y轴(从下往上)，z轴(从屏幕里往屏幕外)。x,y的坐标范围均为-1.0-1.0。在涉及深度之前，暂不讨论z轴，只把它定为0.0。</p><p> </p><h4 id="片元着色器"><a class="markdownIt-Anchor" href="#片元着色器"></a> 片元着色器</h4><p>片元着色器里，我们定义了该点的颜色：</p><pre class="highlight"><code class="glsl"><span class="hljs-type">void</span> main(){  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);  <span class="hljs-comment">//设置颜色</span>}</code></pre><p>类似于顶点着色器，片元着色器的内置变量是gl_FragColor。这个四维向量代表RGBA值，范围不同于之前用过的，WebGL遵循了Opengl颜色分量的取值范围，所以四个参数范围在这里都是0.0-1.0。</p><h4 id="清空绘图区"><a class="markdownIt-Anchor" href="#清空绘图区"></a> 清空绘图区</h4><p>进行绘制前，我们首先要清空一次颜色缓冲区。首先指定清空缓冲区的背景颜色，然后清空缓冲区。</p><pre class="highlight"><code class="javascript">    <span class="hljs-comment">//指定清空颜色缓冲区的颜色</span>    gl.clearColor(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);    <span class="hljs-comment">//清空颜色缓冲区</span>    gl.clear(gl.COLOR_BUFFER_BIT);</code></pre><p>一旦指定了背景色，背景色就会驻存在WebGL系统中，在下一次调用gl.clearColor()方法前不会改变。</p><p> </p><h4 id="画一个点"><a class="markdownIt-Anchor" href="#画一个点"></a> 画一个点</h4><p>使用gl.drawArrays(mode, first, count)函数进行绘制。</p><pre class="highlight"><code class="javascript">    <span class="hljs-comment">//绘制一个点</span>    gl.drawArrays(gl.POINTS, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre><p>顶点着色器会被执行count次，随后每个顶点调用一次片元着色器。</p><p>怎么用看这个:</p><p><img src="/article/webgl(1)/3.png" alt></p><p>至此，就完成了一个点的绘制。效果如下(恶趣味的红配绿)：</p><p><img src="/article/webgl(1)/4.png" alt></p><p>本文的代码放在<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night/tree/WebGL1" target="_blank" rel="noopener">github</a>。</p><p>考虑的后续可能的一些骚操作，对initShaders()进行了一些改写，把绑定program提出来了(暂时影响不大，可以忽略)。</p><p> </p><h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3><hr><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/20/hello-world/"/>
      <url>/2019/05/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p>It’s a line for test.</p><h1 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h1><h2 id="quick-start-2"><a class="markdownIt-Anchor" href="#quick-start-2"></a> Quick Start</h2><h3 id="quick-start-3"><a class="markdownIt-Anchor" href="#quick-start-3"></a> Quick Start</h3><h4 id="quick-start-4"><a class="markdownIt-Anchor" href="#quick-start-4"></a> Quick Start</h4><h5 id="quick-start-5"><a class="markdownIt-Anchor" href="#quick-start-5"></a> Quick Start</h5><h6 id="quick-start-6"><a class="markdownIt-Anchor" href="#quick-start-6"></a> Quick Start</h6><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="c">$ hexo deploy<span class="hljs-keyword">int</span> main</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Neverland</title>
      <link href="/1999/08/28/Neverland/"/>
      <url>/1999/08/28/Neverland/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录Blog创建以来的一些想法。</p></blockquote><p>  </p><p>  </p><p>2019.7.25</p><p>  学期初因为小王的关系了解到Hexo，之前也确实看到过一些前辈的Blog，当时没有深究是怎么实现的。看到小王很开心地发Blog，半羡慕半跟风的心态，于是5月的时候照着一篇教程开始弄。</p><p>  建好了以后因为懒，而且美化起来确实有点麻烦（强迫症_(:з」∠)_…），于是放置了很长一段时间没有去搞。期间也尝试先用markdown写一些笔记，比如DB\ADS的一些，不过感觉有点苦手，之后还是换回了oneNote。</p><p>  中间虽然很长时间没有碰这个Blog，但很多时候还是会想起来，我要改哪些地方、之后打算发什么……之类的一些念头。想到自己，大一大二两年都有些迷茫，绩点什么的也都挺难看的，有时候不知道该做什么，或者明知道自己该做什么而不愿意去做、消极地逃避。大一上可能会是我大学四年里最认真的时间段了，虽然那个时候的我觉得自己真烂、怎么会这么菜，但从此时的角度回望过去，那个时候的投入程度比之现在也已经是可望不可即的程度了。</p><p>  从大学开始到现在越来越自闭，在人多的地方一个人的话会感觉到一种被压迫的窒息感，于是我不经常去食堂了，一个人上课有时候也心不在焉，但如果碰到认识但不熟悉的人会感觉更加的怪…不知道怎么去改善，如果py她们在的话我可能会感觉好一些，但是大家都不在一个学校了…</p><p>  我潜意识里觉得这个Blog可能会是能让我沉浸下来的一个东西，至少我有一个可以自己搭建的世界了。我看的那篇Hexo教程里引用了<a href="https://www.cnblogs.com/jhzhu/p/3893297.html" target="_blank" rel="noopener">这篇文章</a>，里面讲到作者写博客的理由：</p><blockquote><p>一是, 我不再那么乐于去学新的注定不会成为体系的东西了, 因为它除了能展示一下小聪明, 时间回报率特别小.<br>二是, 如果我决定去深究一个东西, 我一定要完全搞懂, 并认真总结一篇博客让我以后能在短时间拾起来(因为不搞懂你很难写一篇半年后还能理解的博客).</p></blockquote><p>  看到这段话以后我开始觉得完善自己的Blog不是那么一件虚无缥缈的事情了，至少它对我而言是有意义的。之前我总是东学一点、西学一点，但是半年过去、一年过去后，我又要花大量的时间从头开始捡起这样东西，从头开始再踩一遍我从前踩过的坑，这本不必要。如果我能记下来这些微小的东西，哪怕它本质上是很傻白甜的问题，但只要它对我有意义，那就是值得的。</p><p>  对我而言，这个Blog的存在也有一点私心。几个月前知道了百度屏蔽了2017年前所有贴子的消息，一瞬间有种心如死灰的漠然。</p><p>  如果以小学五年级为起点开始丈量，我人生有将近八年的时间是花费在贴吧上的——尽管高中开始的三年只是将其作为一个记录心情的地方。吧龄9.7年，发贴7415个，三个贴吧的吧主，在其中的投入已经不是用“心血”可以形容的了。而那些与形形色色来自全国各地的好友的回忆，那个在某个动漫贴吧经营过的流光字铺，那些一个字一个字敲出来的教程贴和个人向推荐贴，以及我悲哀的凝滞而不可挣脱的呓语，全都没有了。我不会再知道那个在我的碎碎念里路过，留下自己的文字，患有视神经病变的那个人是谁了；我不会再想起来曾经触动过我的那些故事的名字一一为何了；我不会再有机会写下那些蕴杂着彼时痛苦与扭曲的情感的文字了。我曾防备现实中记忆的证据的失落，但我不会想到有一天，连虚拟的记录也会不经挽留地消逝，并且是这样毫无征兆地。</p><p>  我不可能再承受下一次数据的失落了，对于记忆力日渐下降的我而言，记录是必要的，但是我不能再把这些记录交给不可靠的第三方了。那样的代价是，当我试图离开他们的领域，我就将失去我的一切。</p><blockquote><p>我走的时候，我还不知道曾经的生活有一天，会需要证明。<br>有一天会再没有人能够相信过去。我也会对以往的一切产生怀疑。那是我曾有过的生活吗。<br>……<br>还有，在它们中间悄无声息度过童年、少年、青年时光的我，他的快乐、孤独、无人感知的惊恐与激动……对于今天的生活，它们是否变得毫无意义。</p></blockquote><p>  </p><p>  </p><p>2019.5.20</p><p>搭建了Blog，之后因为界面方面的问题一直在做一些小的修补：</p><pre><code>修复了首页挂掉的busuanzi API。更换了各种图片，关闭了原有的评论，之后有空大概会换成valine。在每篇文章底下加了pre和next，顺便改了下h1-h6的字体大小。这个主题修了八百年的代码高亮终于修好了，这就是用冷门主题的代价吗？引入highlight.js包以后直接在layout.ejs最后加了。主题风格在加入的css里设置选择。原css与高亮存在冲突，修改了main.min.css里的pre&gt;code的颜色，注释掉了.highlight的整个部分。(这个主题的CSS真是让人摸不着头脑)高亮还存在bug，进入页面需要刷新一次才能正常显示高亮。(懒得管了，以后再说)...</code></pre><p>大抵是这些，之后若有对原主题的改动也会加在这里。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>photo</title>
      <link href="/photo/index.html"/>
      <url>/photo/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
